<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc subcompact="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>

<rfc ipr="trust200902" docName="draft-vanrein-tls-kdh-04" category="std">

<front>

	<title abbrev="TLS-KDH">TLS-KDH: Kerberos + Diffie-Hellman in TLS</title>

	<author initials="R" surname="Van Rein" fullname="Rick van Rein">
		<!-- <organization>OpenFortress B.V.</organization> -->
		<organization>ARPA2.net</organization>
		<address>
			<postal>
				<street>Haarlebrink 5</street>
				<city>Enschede</city>
				<region>Overijssel</region>
				<code>7544 WP</code>
				<country>The Netherlands</country>
			</postal>
			<email>rick@openfortress.nl</email>
		</address>
	</author>

	<date day="13" month="June" year="2016"/>

	<abstract>
	<t>This specification defines a TLS message flow with Kerberos-based
	(mutual) authentication, binding in Elliptic-Curve Diffie-Hellman to
	achieve Forward Secrecy for the session.</t>

<t>TODO: Deprecates RFC2712</t>
	</abstract>

<!--

CHANGES FROM 04 TO 05:
* Showed CAMELLIA-based Cipher Suites in the IANA Considerations as well
* TODO: Consider to drop TicketRequestFlags
* TODO: Consider passing additional tickets through authzdata; notify needs too?
* TODO: How secure is it to let the server submit its TGT?  Does KDC check enough?

CHANGES FROM 03 TO 04:
* Forbidden KDH-Enhanced with subkey in Authenticator; required it in KDH-Only
* For KDH-Only pre-master secret ignore Ticket, but hash entire Authenticator
* Re-added CAMELLIA128/256/256-based CipherSuites with GCM and SHA256/384/512
* Server Certificate sent in KDH-Only, maybe empty, as with Client Certificate
* Added 512-bit CipherSuites
* Merged "Related Work" into "Comparison to Earlier Work"
* Added deprecation of RFC 2712 (to abstract as textual TODO)
* Wrote Acknowledgements section
* Redefined backend tickets, and removed questioning it
* Ticket length 0 marks refusal to provide a ticket

CHANGES FROM 02 TO 03:
* No longer dependent on exchange of TicketRequestFlags to detect/allow TLS-KDH
* Changed to KerberosTicket as client_certificate_type, RFC 7250
* Enabled a  KerberosTicket as server_certificate_type for user-to-user KDH-only
* Server may choose any server_certificate_type it likes when KDH-enhanced
* Wrote the IANA Considerations section

CHANGES FROM 01 TO 02:
* Simplified the wire representation of TicketRequestFlags
* Added conceptual data per connection: TicketRequestFlags, possibly KDH-only/-enhanced

CHANGES FROM 00 TO 01:
* Taken out protocol-bound DH; this saves about 75% of the complexity
* Pre-master secret now incorporates Kerberos session key and DH shared secret
* Integration with "normal" X.509 certificates; client may use krb5 certificate
* Kerberos Ticket as X.509 pubkeyinfo; Authenticator as signature mechanism
* Define TLS-standardised hashes as ChecksumTypes for use in an Authenticator
* Moved TicketRequestFlags to a TLS Extension; negotiation with min/max flags
* Added descriptions of how to support backend servers in Ticket AuthData

-->

</front>


<middle>

<section title="Introduction" anchor="intro">

<t>Kerberos lends itself well to infrastructure-supported mutual
authentication, and can even be used to crossover between realms. A
downside of this infrastructure is that a crack of one key can lead to a cascade
of reverse-engineered keys.  Diffie-Hellman key exchange, nowadays primarily
in its Elliptic-Curve variation, can be used to
incorporate the desirable property of Forward Secrecy, but its
vulnerability to man-in-the-middle attacks must then be overcome by cryptographically
binding it to an authentication mechanism.</t>

<t>This specification describes how Kerberos data structures can be used for
TLS client authentication, by introducing a new certificate type for use with TLS.
The server can choose to provide a Certificate with a traditional
signing mechanism such as RSA for authentication,
in which case this specification speaks of a KDH-enhanced exchange;
even when presenting no server certificate at all, a client-side
Kerberos ticket can be used for mutual authentication in what will then be called a
KDH-only exchange.  The KDH-enhanced variety uses existing CipherSuites, and KDH-only
defines new CipherSuites.  Both KDH-enhanced and KDH-only message flows
will be referred to as TLS-KDH.</t>

<t>A variation of the KDH-only flow does incorporate a server-side ticket;
this can be used for user-to-user authentication, perhaps to be used in
peer-to-peer protocols that use TLS-KDH as their security foundation.</t>

<t>Both TLS-KDH variations form a cryptographic binding between Kerberos
and Elliptic-Curve Diffie-Hellman (ECDH), leading to the combined advantages of
infrastructure-supported mutual authentication and Forward Secrecy.</t>

<t>The normal flow of TLS-KDH messages is basically a standard interaction
with a modified form of client Certificate and CertificateVerify:</t>

<figure><artwork><![CDATA[
    Client                                               Server

    ClientHello                  -------->
                                                    ServerHello
                                             Server Certificate*
                                              ServerKeyExchange
                                             CertificateRequest
                                 <--------      ServerHelloDone
    Client Certificate
    ClientKeyExchange
    CertificateVerify
   [ChangeCipherSpec]
    Finished                     -------->
                                              [ChangeCipherSpec]
                                 <--------             Finished
    Application Data             <------->     Application Data
]]></artwork></figure>

<t>* Indicates that Server Certificate may be empty; it is present
in KDH-enhanced message flows, and usually empty in KDH-only message flows.</t>
TODO: empty or DER NULL?  Then we can drop the *

<t>[] Indicates that ChangeCipherSpec is an independent TLS
protocol content type; it is not actually a TLS
handshake message.</t>


</section>


<section title="Extending Kerberos to support TLS" anchor="ext.krb">

<t>This section specifies individual extensions to Kerberos that make it possible
to use TLS.</t>

<!--
DROPPED SECTION - BUSINESS AS USUAL DOES NOT NEED TO BE SPECIFIED
<section title="Finding the PrincipalName and Realm" anchor="ext.krb.remoteid">

<t>Clients find these parameters are found through existing Kerberos functionality,
procure service tickets that use them and pass those to the service.<t>

<t>The principal name of a service typically contains a
service name, host name and realm; the service name is commonly known
in the application run over TLS; the host name has generally been used to locate
the server; the realm name is not directly known but can usually be derived from
the host name, although the precise manner in which this is done
falls outside the scope of this specification.  A flexible
configuration of a Kerberos realm may be supportive of crossover to
remote realms, but it would violate security to suggest a remote realm in the TLS
exchange itself.</t>

</section>
-->

<section title="Checksum Types for use with TLS" anchor="ext.krb.csumtypes">

<t>The IANA registry of Kerberos Parameters defines a number of Checksum
Types.  This includes keyed and non-keyed checksums.  We introduce
checksum types to match the secure hash algorithms that are used in TLS.</t>

<t>There already are two values to represent SHA1.  An implementation that
processes Checksum Types MAY send either and MUST accept both as equivalent
indications.</t>

<t>The following additional Checksum Types are introduced for use with TLS
[Section 7.4.1.4.1 of <xref target="RFC5246"/>]:
<list style="symbols">
<t>SHA224</t>
<t>SHA256</t>
<t>SHA384</t>
<t>SHA512</t>
</list>
</t>

</section>

<section title="Authenticators as Signatures" anchor="ext.krb.authsig">

<t>Kerberos has a symmetric analogue to a signature, in the form of an Authenticator
[Section 5.5.1 of <xref target="RFC4120"/>].  When used in TLS-KDH,
the Authenticator MUST have a secure hash embedded
in the cksum field.  The checksum type used in the context of TLS MUST be taken to
match one of the entries in IANA's TLS HashAlgorithm Registry.</t>

<t>The Authenticator is not sent in the plain, but encrypted with a Kerberos
session key as EncryptedData [Section 5.2.9 of <xref target="RFC4120"/>]
and this is how Kerberos derives authenticity: only the client and the
service can pack and unpack the EncryptedData and process the Authenticator.</t>

<t>A standard part of an Authenticator is a timestamp with microsecond
accuracy.  In Kerberos, this is generally validated within a small window
around the independently
sycnchronised time of the TLS client and server.  It is customary to
allow a time window of about 5 minutes around the server time.</t>

<t>To avoid replay attacks, Kerberos solutions sometimes need to remember received
Authenticators, or their time stamps, until the time window has passed.
This complicates servers, especially for redundant deployments.  As used in TLS-KDH,
with entropy from both ends in the hello exchange and with session-specific keys
agreed through ephemeral ECDH, there is no need for such infrastructure to avoid
replay attacks.  Notwithstanding that it is not as strong a requirement as
under other Kerberos applications, the cusec and ctime fields are
present in the Authenticator and MUST be
filled with the current time by the TLS-KDH client, and SHOULD be verified to
fall within a reasonable time frame on the TLS-KDH server.</t>

<t>In KDH-Enhanced mode an Authenticator MUST NOT contain a subkey field.
In KDH-only mode, such a field MUST be supplied as input to the
premaster secret computation.</t>

<t>Other optional fields in the Authenticator than specified above SHOULD NOT be produced
and MUST be ignored by the recipient.</t>

<t>The representation on the wire matches the DigitallySigned structure
[Section 4.7 of <xref target="RFC5246"/>] with the signature algorithm
set to kerberos, the hash set as desired for the TLS flow.  The opaque
contents of the signature are filled with the literal bytes of the
Authenticator, which MUST NOT be an empty string.</t>

</section>


<section title="Tickets in the TLS Certificate flow" anchor="ext.krb.cert">

<t>This specification defines a new certificate type <xref target="RFC7250"/>
named KerberosTicket, to be negotiated for the client and, though only in special
circumstances, for the server.</t>

<t>The Kerberos Ticket is included in certificate messages following this
syntax:</t>
<figure><artwork><![CDATA[
struct {
    select(certificate_type){

         // certificate type defined in this document.
         case KerberosTicket: opaque Ticket<0..2^24-1>;

        // Additional certificate type based on
        // "TLS Certificate Types" subregistry
    };
} Certificate;
]]></artwork></figure>
<t>In this syntax, Ticket holds the DER-encoded form of a Kerberos
Ticket [Section 5.3 of <xref target="RFC4120"/>].  The special case
where the Ticket field has length 0 marks an invalid ticket representation,
and is treated by TLS-KDH as a refusal to send the requested ticket.</t>

</section>

<section title="AuthorizationData for Backend Services" anchor="tls.ext.backend">

<!--
<t>DISCUSSION: This is an alternative to S4U2Proxy, which relies on the server realm
to care for the provisioned rights.  If TLS-KDH is to scale up to more loose
collaborations, without implied mutual trust, then it needs a new method for
backend service support.  This is defined below.</t>
-->

<t>The TLS server may depend on additional Kerberos-protected services,
generally referred to as "backend services".  As an example, a webmail service
may need to access IMAP and SMTP backend services, possibly under independent
administrative control.  This section describes an OPTIONAL Kerberos
mechanism in support of such backend services.  It is designed to even work
when the client and server reside in independently administered realms.</t>

<t>In addition to the main Ticket supplied in the client Certificate's
public key field, the TLS server MAY be sent additional Tickets for access to
backend services, and in some cases these additional Tickets can define where these
backend services are located and under what client identity they are accessed.
The client needs to provide these additional Tickets in an AuthorizationData
element whose ad-type is AD-BACKEND-TICKETS (TBD) and whose ad-data
holds a KRB-CRED message [Section 5.8 of <xref target="RFC4120"/>]
with an enc-part that uses NULL encryption [Section 6.3.1 of <xref target="RFC1510"/>].</t>

<t>AuthorizationData elements with additional Tickets MAY be part of the service Ticket and/or Authenticator; supporting TLS servers MUST collect them from both these locations, such that they prefer the former in cases of service name clashes.  Just like a KDC could store additional Tickets in the main Ticket, an explicitly configured client could store them in the Authenticator.  To remain secure, clients MUST NOT be open to servers requesting arbitrary additional Tickets in any way.</t>

<t>Additional Tickets MUST NOT be renewable, but the main Ticket
MAY be; when the
main Ticket is renewed it SHOULD be resent with the backend extension
as they are setup at that time.  Additional Tickets SHOULD have
neither the FORWARDABLE nor the PROXIABLE flag set.</t>

<t>Additional Tickets should normally be supplied every time the main Ticket is supplied
for TLS-KDH.
As a result, both the main and additional Tickets MAY be forgotten by the
server whenever a TLS-KDH session ends.  However, when needed for longer-lasting
or deferred backend processing, the server MAY hold the Tickets longer.</t>

<t>It is possible for backend services to rely on backend services themselves;
this can be facilitated by a an AD-BACKEND-TICKETS element contained in the
additional Ticket for the respective backend Ticket or, in more complex
situations requiring more coordinated configuration, in an Authenticator whose
additional Tickets get passed on selectively in Authenticators or other
protocol elements sent to the backend service.</t>

<t>The inclusion of additional Tickets in an Authenticator is not further
described in this specification.  The inclusion of additional Tickets in a
main Ticket usually involves requesting the TLS-KDH service Ticket directly
from the client's KDC.  TODO: To facilitate this, the server desiring additional
Tickets SHOULD set the LocalRealmService
flag <xref target="tls.ext.tickreq"/>; without this flag, the client MAY choose
not to supply additional Tickets.  The use of this flag may imply that the server
needs to be flexible in the identity that the client uses for its service.</t>

<!--
TODO:REALLY-DEFINE-HERE?
To support an alternate path, we define the following typed data format
for errors that the KDC can send
to require a client to supply an AD-BACKEND-TICKETS with Tickets in the
requested order in addition to a request that it just made.  The client MUST NOT
accept this indication from any KDC but its own.</t>

<figure>
<artwork>
<![CDATA[
   TD-REQUIRED-BACKEND-TICKETS  ::=  SEQUENCE OF SEQUENCE {
	   realm	[0] Realm,
	   sname	[1] PrincipalName
   }
]]>
</artwork>
</figure>
-->

</section>


<!--
<section title="Interaction with Kerberos Clients" anchor="krb.ext.clients">

DROPPING THIS ENTIRE SECTION; IT IS OUT OF SCOPE AND FAR TOO DETAILED.

<t>A client willing to employ Kerberos authentication offers one or more
of the TLS-KDH CipherSuites in its ClientHello message. Offering these
is no guarantee that a token has already been found for the server, but it
expresses a willingness to look for one.</t>

<t>Whether a client is willing to employ Kerberos authentication MAY depend
on its context.  Following is an informative example of situations that could
be considered, with a rising level of willingness:
<list style="numbers">
<t>Kerberos software is available on the client system</t>
<t>The client context holds a Ticket Granting Ticket that is currently valid</t>
<t>The client context holds a Ticket Granting Ticket that may have expired</t>
<t>The client context will go through Kerberos signup if need be</t>
</list>
The last two options may require interaction with the user, and are not suitable for every kind of application.  The first and last options are too extreme to be defaults, but depending on the ability to interact, the middle two can be useful as defaults that may be overridden by users.</t>

<t>The client may have locally configured realms, and/or it may lookup a realm
name in secure DNS <xref target="KREALM"/>.  Combined with the
service protocol and server name, this helps the client to form one or more
service principal identifier.  These can be used in Kerberos' TGS protocol.</t>

<t>Before obtaining a Kerberos ticket, several considerations could be taken into
account by the TLS-KDH client to select and/or order suitability of
principal names for a desired ticket:
<list style="symbols">
<t>Local policy could specify a service principal name to always use for a
particular service protocol and/or server name and/or realm name;</t>
<t>Local policy could specify a client principal name to always use for a
particular service protocol and/or server name and/or realm name;</t>
<t>A realm name match with a principal ticketâ€™s realm could suggest
using that;</t>
<t>Prior availability of a service ticket could suggest using the
service principal name in that ticket;</t>
<t>Prior availability of a service ticket could suggest using the
client principal name in that ticket;</t>
<t>Prior availability of a ticket granting ticket could suggest using
that.</t>
</list>
</t>

<t>In addition to this choice in service name to request, the client may wish
to modify its own name, perhaps to a group name or a pseudonym, according
to local policy and/or historic choices made.  Such mechanisms need not
be specified here, since they are a local matter to the client-side Kerberos
solution.  One default procedure is however RECOMMENDED, namely to
send an anonymous ticket <xref target="RFC6112"/> when the server has not
set the UniqueClientIdentity flag; but to instead use a non-anonymous ticket
when the anonymous ticket includes the anonymous realm name while the sever
has set the VisibleClientRealm flag.  The client SHOULD interact with the
user to request permission for releasing the identifying information if
possible, but the mechanism MAY store choices for future use in similar
situations.  Finally, the client-side Kerberos solution MAY obtain a
pseudonymous name such as one based on NT-UID principal names
[Section 6.2 of <xref target="RFC4120"/>] when the server has sent the
UniqueClientIdentity flag; it is up the client whether this is a short-lived
or long-lived identity.</t>

<t>Given the options that are now available, the TLS client SHOULD proceed in
attempts to obtain a service ticket, until either a ticket is assigned or
all options for obtaining one have been exhausted.  When no ticket can be
obtained, the TLS client MUST send a TLS Alert and shut down the connection.
The client might reconnect without offering TLS-KDH
CipherSuites in response to a temporary local cache holding the negative result on a
prior attempt.</t>

</section>
-->

</section>

<section title="Extending TLS to support Kerberos" anchor="tls.ext">

<t>This section describes changes to TLS in support of Kerberos.</t>

<section title="Conceptual Data Model Extensions" anchor="tls.ext.data">

<t>The following conceptual data should be available while the TLS-KDH message flows
evolve:
<list style="symbols">
<t>A flag that is initially set, indicating that the connection could be a KDH-enhanced connection;</t>
<t>A flag that is initially set, indicating that the connection could be a KDH-only connection;</t>
<t>A series of TicketRequestFlags that can be requested when the client obtains a Ticket for this service.</t>
</list>
</t>

</section>

<section title="Certificate Type KerberosTicket" anchor="tls.ext.certtp">

<t>This specification adds a new entry named kerberos_sign in IANA's
TLS ClientCertificateType Identifiers Registry, with the value TBD.</t>

<t>This specification also adds a new entry named KerberosTicket in IANA's
TLS Certificate Types" subregistry of the "Transport Layer Security (TLS) Extensions"
registry.</t>

</section>

<section title="Signature Algorithms" anchor="tls.ext.sigalg">

<t>This specification introduces a mechanism for signatures under Kerberos
<xref target="ext.krb.authsig"/>.  This mechanism is represented in two
places.</t>

<t>In TLS, a new SignatureAlgorithm named kerberos is allocated with
value TBD in IANA's TLS Parameters Registry.  This Kerberos SignatureAlgorithm
is usually combined with a HashAlgorithm that is in common use with TLS, to
form a SignatureAndHashAlgorithm.  The digitally-signed structure
[Section 4.7 of <xref target="RFC5246"/>] uses this structure, followed by
a variable-sized opaque byte sequence, which should hold the EncryptedData
holding an Authenticator <xref target="ext.krb.authsig"/>.</t>

</section>

<section title="KDH-only CipherSuites" anchor="ext.tls.krbonly">

<t>KDH-enhanced message flows can use existing ECDHE CipherSuites using
server certificates that may be signed with RSA or other common algorithms.
In addition, this specification
introduces a number of KDH-only CipherSuites with names that start with
TLS_ECDHE_KDH_.  These new CipherSuites rely on Kerberos' mutual authentication
plus ECDHE but not on a server Certificate.  They may be used starting from
TLS 1.2.  They default to a higher verify_data_length than the default 12.</t>

<t>The following Kerberos-only CipherSuites are entered into the
IANA TLS Cipher Suite Registry; the list below provides their names and
their desired verify_data_lengths between brackets:
<list style="symbols">
<t>TLS_ECDHE_KDH_WITH_AES_128_GCM_SHA256 (32)</t>
<t>TLS_ECDHE_KDH_WITH_AES_256_GCM_SHA384 (48)</t>
<t>TLS_ECDHE_KDH_WITH_AES_256_GCM_SHA512 (64)</t>
<t>TLS_ECDHE_KDH_WITH_AES_128_CCM (32)</t>
<t>TLS_ECDHE_KDH_WITH_AES_256_CCM (48)</t>
<t>TLS_ECDHE_KDH_WITH_AES_128_CCM_8 (32)</t>
<t>TLS_ECDHE_KDH_WITH_AES_256_CCM_8 (48)</t>
<!--
<t>TLS_ECDHE_KDH_WITH_ARIA_128_GCM_SHA256 (32) (TODO:WHY IS ARIA IN TLS 1.3?)</t>
<t>TLS_ECDHE_KDH_WITH_ARIA_256_GCM_SHA384 (48) (TODO:WHY IS ARIA IN TLS 1.3REALLY?)</t>
<t>TLS_ECDHE_KDH_WITH_ARIA_256_GCM_SHA512 (64) (TODO:WHY IS ARIA IN TLS 1.3REALLY?)</t>
-->
<t>TLS_ECDHE_KDH_WITH_CAMELLIA_128_GCM_SHA256 (32)</t>
<t>TLS_ECDHE_KDH_WITH_CAMELLIA_256_GCM_SHA384 (48)</t>
<t>TLS_ECDHE_KDH_WITH_CAMELLIA_256_GCM_SHA512 (64)</t>
</list>
Neither server nor client should accept lower values for verify_data_length
than given here.
TODO: the list follows http://www.keylength.com/en/4/ and the hash algorithm sizes -- is this agreed?</t>

<t>The premaster secret for KDH-only CipherSuites is composed from an
ECDHE shared secret and a client-sent, connection-specific Kerberos key.
Use A to refer to the DER representation of the
Authenticator in the ClientVerify message, after it has been decrypted
by the service.
Perform the ECDH computation in the normal manner <xref target="RFC4492"/> and
let Z be the value produced by this computation (with leading zero bytes
kept as they are).  The premaster secret is the concatenation of an uint16
containing the length of Z (in octets), Z itself, an uint16 containing
the length of A (in octets) and A itself.</t>

<t>The master secret is derived from the premaster secret using the
extended master secret computation [Section 4 of <xref target="RFC7627"/>.</t>

</section>

<section title="TicketRequestFlags Extension" anchor="tls.ext.tickreq">

<t>Some clients may be able to offer more facilities in Tickets than others,
and some servers need more than others.  To communicate this, a TLS Extension
known as TicketRequestFlags is hereby defined.  This extension is optional; when
absent, all flags are considered to be cleared.  The client uses the Extension
to specify the flags that it understands and may be able to fulfil.
The server uses the Extension to indicate the flags that it would like to be
fulfilled.</t>

<t>The Extension's structure is an extensible list of flag values that indicate
constraints on the ticket that the client should try to supply.  These should
be seen as hints how the client should present its identity, as the server
can always decide to reject a client on grounds that are or are not
expressible in this form.</t>

<t>Flag values defined in this specification are:
<list style="hanging" hangIndent="6">

<t hangText="TicketFlags (flags number 0..31)">
	are taken from Kerberos' TicketFlags definitions [<xref target="RFC4120"/> and updates]; clients MUST NOT accept requested TicketFlags without scrutinising their security impact; servers SHOULD NOT assume that their requested TicketFlags will actually be provided.  Only TicketFlags 0 through 31 are included in this definition; when Kerberos is extended with more TicketFlags then they will be assigned a new range of values as TicketRequestFlags.</t>

<!-- CROSSOVER IS BEST INDEPENDENTLY ARRANGED
<t hangText="CrossoverRealm (flag number TBD)">
	indicates that the client SHOULD be inquisitive about redirections to other realm than its own; this MAY be defined in locally trusted domain-to-realm mappings; and the client SHOULD request a service ticket under canonicalization <xref target="RFC6806"/> and be open to server referrals.  When this flag is not set, the server MUST accept the client realm on the tickets received, and its setup must make the effort of connecting to the realm of the clients that it wants to support.</t>
-->

<t hangText="VisibleClientRealm (flag number 32)">
	requests that the client's realm name is revealed in the service ticket.  With the flag not set, the server MUST NOT reject the well-known anonymous realm name WELLKNOWN:ANONYMOUS [Section 3 of <xref target="RFC6112"/>] in the client realm name.</t>

<t hangText="UniqueClientIdentity (flag number 33)">
	requests that the client presents a unique identity, even if it is a pseudonym that is specific to this service.  Some services can make good use of identities that are also presented over other protocols, which is why the choice to share such an identity SHOULD be made during an interaction with the user, if possible.  The user MAY determine to use only a short-lived identity.  When this flag is not set, the server MUST NOT reject the client principal name WELLKNOWN/ANONYMOUS of type KRB_NT_WELLKNOWN [Section 3 of <xref target="RFC6112"/>].  Regardless of this flag, it is RECOMMENDED for the server to be open to as many forms of client principal name [Section 6.2 of <xref target="RFC4120"/>] as possible.</t>

<t hangText="LastingClientIdentity (flag number 34)">
	requests that the client presents an identity that it will use on recurring visits.  Client software is advised to confer with their users on this, and so this request should only be used for subscription services that would be agreeable to their users.  Without this flag, the client is free to use a short-lived identity that is unlikely to survive after the ticket's endtime or renew-till time.</t>
</list>
</t>

<!--
<t>DISCUSS:FUTURE:AssertionStatement (flag number TBD) indicates that the service ticket should contain a SAML Assertion Statement as part of a typed hole in the authenticator.  The future extension defining this may expand IANA's "TLS Authorization Data Formats Registry" (as introduced by RFC 5878) with identifiers for an AttributeQuery, presented either inline or as a URL-and-hash combo.  This enables the server to pass an AttributeQuery to the client in the ServerHello.  The client can use this to ask the client what to do, to select a client identity / pseudonym to use for this service, and subsequently to request the KDC to supply an agreed-upon set of attributes.  Without this passing of an AttributeQuery, the client would need to guess or manually setup a set of attributes that the server requests or requires.  Note that the server is free to accept a not-so-informative SAML statement and provide feedback through the application protocol on what it might be missing.</t>
-->

<t>The flags are chosen such that their default values may be set to 0 as a safe default; safe in the sense that they do not lead to privacy problems, do not impair the peer and do not offer something that could block progress of TLS at a later point.  Servers MUST NOT respond with TicketRequestFlags set that the client left cleared.  Senders MUST NOT include flags that they don't know and recipients MUST NOT accept flags they cannot interpret.</t>

<t>Flag values are registered by IANA in a newly created "TLS-KDH Ticket Request Flag Registry", whose initial values are as defined above.  Future specifications of flag values may state that a flag is an alternative to another flag, including to the ones specified above.  When flag A is an alternative to flag B then the fulfillment of the requirements for A suffices to ignore flag B.  It is possible for flags to cyclically refer to each other as alternatives; since being-an-alternative is not defined as a transitive property, this need not distract from this definition.  This is explicitly permitted to enhance expressiveness of this principle.</t>

<t>The wire format representing TicketRequestFlags is a sequence of bytes, where the byte at index i (starting from 0) represents the flags numbered 8*i (in its least-significat bit) through 8*i+7 (in its most-significant bit).  The last byte MUST NOT be 0, meaning that it is possible for the TicketRequestFlags to be a sequence of no bytes if all flags are cleared.</t>

</section>

<section title="TLS Connection Expiration" anchor="cnxrefresh">

<t>TLS-KDH connections expire when their authenticating Kerberos tickets
expire.  This is not a reason for termination of the TLS connection, but
instead it is a trigger for refreshing the ticket.  Such a refresh should
be executed by the TLS-KDH client, where it may trigger user interaction.
Note that Kerberos' facility of ticket renewal
[Section 2.3 of <xref target="RFC4120"/>] may
provide some relief from such user interaction.</t>

<t>When the TLS-KDH connection expires, neither side will send any further data
records, and both sides will, upon receiving any data records, trigger a TLS Alert.
The other records are still accepted, to permit a TLS handshake for re-issuance
of session keys.
Implementations MAY choose to initiate and permit re-authentication some time before
the actual expiration.  This can remedy clock skew between the TLS-KDH client
and server, which might otherwise lead to undesired connection reset.</t>

<!--
<t>Note that this facility can form a potent combination with DTLS
<xref target="RFC6347"/>
by using UDP or SCTP to carry sessions that are dormant for long periods, with
occasional bursts of data.  Such sessions are pre-validated, carrying data bursts
that share the same credentials, that behave as though they were cached.  Only
for reasons of session key expiration must such credentials be occasionally
refreshed.</t>
-->

</section>

<section title="Interaction with Applications" anchor="tls.ext.apps">

<t>To be able to use Kerberos, application protocols that run over TLS must
exchange some configuration information with the TLS stack.  This includes
communication about Kerberos properties such as service name and realm,
offered/requested TicketRequestFlags, and a key for use with the local identity.</t>

<t>When a SASL EXTERNAL mechanism is used to communicate an identity between
the application and the TLS stack, then a good alignment with X.509
certificates is possible when both aim to derive or match a Network Access Identifier
<xref target="RFC7542"/> and/or a
DNS name.  In the case of a Kerberos principal name, this would involve
translation between case-sensitive realm names to DNS names whose case is not
reliably reproduced [Section 4.1 of <xref target="RFC4343"/>];
this may be handled by ignoring or lowering the case of the realm name while being
aware of the requirement that no two realm names may differ only in their case
[Section 7.2.3.1 of <xref target="RFC4120"/>].</t>

</section>

<section title="Kerberos-Only TLS Application Profile" anchor="ext.tls.profile">

<t>TLS and Kerberos have long been independent infrastructures for secure
connectivity; with the introduction of the KDH-only CipherSuites in this
specification, the worlds can merge elegantly.  The newly introduced
CipherSuites are expected to integrate relatively straightforwardly with any
TLS stack.</t>

<t>Just like the TLS-KDH CipherSuites are optimal to implement in TLS stacks,
TLS-KDH should not force all Kerberos applications to process the full potential
of TLS, especially not public key cryptography and the complexity of proper
validation of X.509 certificates.  Some applications simply want to use
Kerberos in a standardised protocol, without any added CipherSuites.  For
such applications, we hereby introduce a TLS application profile under which
such applications can stand on their own:
<list style="symbols">
<t>Based on TLS 1.2 or newer;</t>
<t>Setting a default verify_data_size dependent on the CipherSuite;</t>
<t>Supporting the TLS-KDH CipherSuite TLS_ECDHE_KDH_WITH_AES_256_GCM_SHA512;</t>
<t>Not necessarily supporting the TLS_RSA_WITH_AES_128_CBC_SHA CipherSuite
that is mandatory in the default TLS application profile
[Section 9 of <xref target="RFC5246"/>];</t>
<t>This application profile will be known as the "Kerberos-Only TLS Application Profile".</t>
</list>
</t>

<t>The Kerberos-only CipherSuites can be used with any TLS application profile; that
includes, but is not limited to, the one specified above and the
default application profile.</t>

</section>

</section>


<section title="The Message Flow of TLS-KDH">

<t>This specification introduces the name TLS-KDH to certain message flows within
the TLS framework.  There are two distinct variations, called KDH-only and KDH-enhanced.
This section defines constraints to the message flow for it to be a
TLS-KDH message flow.  This, together with the flags in the conceptual data model
[<xref target="tls.ext.data"/>], guides the use of the extensions defined in this
specification.</t>

<t>TLS endpoints that find that the other side of the TLS connection only
implements some of the TLS-KDH constraints MUST NOT continue the connection
with the TLS-KDH extensions of this specification (unless future specifications
assign a meaningful procedure for such situations).  If the remote endpoint
does not implement all requirements for TLS-KDH but also enforces it, for
instance by sending required information that can only be interpreted under this
specification, then it MUST send a suitable TLS Alert and close the connection.</t>

<section title="ClientHello" anchor="clienthello">

<t>To support TLS-KDH, a client's ClientHello MUST mention the kerberos
SignatureAlgorithm in at least one of the supported_signature_algorithms,
and it also MUST include KerberosTicket in a client_certificate_type extension
<xref target="RFC7250"/>.  The client MAY include the TicketRequestFlags extension
if it is interested on providing more than a generally available ticket to the
service.</t>

<t>Furthermore, the client MAY offer to process
KerberosTicket in a server_certificate_type extension <xref target="RFC7250"/>,
and the client MAY include the TicketRequestFlags extension.</t>

<t>In addition, the ClientHello MAY include one or more KDH-only CipherSuites
in the list of cipher_suites, but if that is done the protocol used MUST be
TLS 1.2 or later, indicated on the record layer with ProtocolVersion 3,3 or
later.  Without at least one of the KDH-only CipherSuites, the connection
cannot be KDH-only, but it may still proceed as KDH-enhanced.  With at least
one of the KDH-only CipherSuites, the client MAY offer to process KerberosTicket
in a server_certificate_type extension <xref target="RFC7250"/> through the
ENC-TKT-IN-SKEY [Section 2.9.2 of <xref target="RFC4120"/>] Kerberos extension.</t>

<t>The client MUST NOT send TicketRequestFlags that it does not understand and
it MUST NOT offer all the TicketFlags that are defined for Kerberos, but instead
SHOULD limit itself to what would be acceptable from a security perspective.</t>

</section>

<section title="ServerHello" anchor="serverhello">

<t>To support TLS-KDH, a ServerHello message
MUST mention the kerberos SignatureAlgorithm in at least
one of the supported_signature_algorithms, and it MUST include the KerberosTicket
value in the client_certificate_type extension <xref target="RFC7250"/>.
Furthermore, the server MUST select a cipher_suite with ephemeral ECDH
key exchange; aside from generally available CipherSuites, the server MAY select
a KDH-only cipher_suite.  When it does not select a KDH-only CipherSuite, the
connection cannot be a KDH-only connection, but it may still proceed as
KDH-enhanced.</t>

<t>When the server selects a KDH-enhanced CipherSuite, it MUST choose another
means of authenticating its identity than through Kerberos, following the
customary flow of TLS and only using Kerberos for client authentication.</t>

<t>When the server selects a KDH-only CipherSuite and when the
ClientHello message includes the KerberosTicket in a
server_certificate_type extension <xref target="RFC7250"/>, then the server MAY
choose to send back a server_certificate_type extension selecting KerberosTicket,
in which case it MUST send the corresponding Server Certificate
later in the process.  This may be used to facilitate user-to-user negotiation
of TLS.</t>

<t>The server MAY include the TicketRequestFlags extension in the ServerHello message
if the client included it in the ClientHello message.
The server MUST ignore TicketRequestFlags from the client that it does not
understand; it MUST NOT send TicketRequestFlags that it does not understand
and it MUST NOT set TicketRequestFlags that were not set in the ClientHello.</t>

<t>Note that none of the Anonymous CipherSuites can be made to work with TLS-KDH,
because then it is not permitted [Section 2.5 of <xref target="RFC4492"/>] to send a
CertificateRequest, client Certificate or CertificateVerify message.  Although the
KDH-only CipherSuites do not use a server Certificate this does not
constitute Anonymous server authentication, because Kerberos provides
mutual authentication.</t>

</section>

<section title="Server Certificate" anchor="srvcert">

<t>For KDH-enhanced CipherSuites, the
server Certificate message MUST be sent, following the definitions of the
server-selected cipher_suite.</t>

<t>Under KDH-only, when the server has not selected the KerberosTicket as the
server_certificate_type, then it MUST send a Certificate message with
a certificate_list of 0 bytes length.</t>
TODO: Alternatively, send a DER NULL (0x05, 0x00) and have better stack integration

<t>Under KDH-only, when the server did select the KerberosTicket as the
server_certificate_type, then it MUST include the corresponding ticket in the
Server Certificate.</t>

</section>

<section title="ServerKeyExchange" anchor="serverkex">

<t>All TLS-KDH connections MUST use ephemeral ECDH.  Under
KDH-enhanced CipherSuites, this implies the case ec_diffie_hellman
[Section 5.4 of <xref target="RFC4492"/>].  Under KDH-only CipherSuites,
the same case is used, but without signatures, formatted in the same way as for
ECDH_anon CipherSuites.</t>

</section>

<section title="CertificateRequest" anchor="certificaterequest">

<t>Under TLS-KDH, a CertificateRequest MUST be sent by the server, and it MUST
include at least one SignatureAndHashAlgorithm based on the kerberos
SignatureAlgorithm.  Any SignatureAndHashAlogorithm with the SignatureAlgorithm
set to kerberos MUST use a HashAlgorithm for which IANA's
Kerberos Parameters registry holds a compatible Kerberos Checksum Type.
The CertificateRequest MUST also list the kerberos_sign CertificateType.
Having selected the KerberosTicket value for the client_certificate_type,
other CertificateTypes and SignatureAndHashAlgorithms SHOULD NOT be sent.
The list of certificate_authorities is not used by TLS-KDH and
MUST be empty.</t>

</section>

<section title="Client Certificate" anchor="clicert">

<t>TLS-KDH clients MUST fill the ClientCertificate message with a
KerberosTicket.  In doing so, it SHOULD take any negotiated
TicketRequestFlags into consideration; it is not required however to
implement all, because some flags may be forbidden by policy that was concealed
from the ClientHello-supplied TicketRequestFlags, or their implementation may
turn out to be unavailable while requesting the Ticket.  In such cases, the
client MAY simply continue without fulfilling the request flags, or it MAY
choose to divert from a KDH-enhanced message flow by authenticating with another
kind of Certificate, or not to present one at all.</t>

<t>When the server has not set the UniqueClientIdentity flag, then the
RECOMMENDED client Certificate under TLS-KDH would be based on an
anonymous Ticket <xref target="RFC6112"/>; however, when the server has
set the UniqueClientIdentity flag, then an anonymous Ticket that uses the
anonymous realm MUST NOT be sent.  A Ticket that is not anonymous may still
be pseudonymous, including names based on NT-UID principal names
[Section 6.2 of <xref target="RFC4120"/>] when the server has sent the
UniqueClientIdentity flag; the LastingClientIdentity flag indicates the
server's perspecitve on longevity of any such pseudonyms, but the
client MAY choose to ignore that wish.</t>

<t>The impact of using an anonymous ticket is that the server cannot establish
the identity of the client, except perhaps that the same service ticket may
be used repeatedly during its short period of validity.  This means that the
ability to trace the client is limited for both server and client.  Under
customary X.509 authentication, the
interpretation of not sending the CertificateRequest is that the
server should not care for the client identity; anonymous tickets provide a
mechanism for achieving a similar pattern under TLS-KDH, although it has some
benefits of short-term session protection.</t>

<t>When the server has selected the KerberosTicket as the
server_certificate_type, then the client SHOULD pass it along with its attempt
to obtain a ticket for the server name, using the KDC option ENC-TKT-IN-SKEY
[Section 2.9.2 of <xref target="RFC4120"/>] and supplying an additional ticket in
the TGS request [Section 3.3.1 of <xref target="RFC4120"/>]; this Ticket is
supplied completely by the KerberosTicket certificate-type, and although it
includes a server-side realm name, this MUST NOT be trusted by the client before
it has been confirmed by the client's attempts to reach the server by its host name;
this is because a man-in-the-middle attack is still possible through a forged
service realm.  Customary processing rules for finding a server's realm MUST
therefore be followed by the client.</t>

<t>The presence of the client's Ticket in the ClientCertificate message
enables the server to ascertain that
the client has procured a Ticket through the formal pathways
of Kerberos, ending in the server-side realm; the reason this can be assumed is
that the ticket holds an encrypted part
that the server can decrypt and thereby validate with its own key, as setup
in its KDC for sharing in service tickets.  In other words, even an anonymous
Ticket establishes that the server may trust that the client was checked along
the way to the service.  As a result, the ECDH key exchange is known to be
protected from a man-in-the-middle attack.</t>

<t>Briefly put, we can speak of mutual authentication in this specification,
even when the client supplies an anonymous ticket.  The only thing that is missing
under an anonymous ticket is the visibility of the client's validated identity.</t>

</section>

<section title="ClientKeyExhange" anchor="clientkex">

<t>Every TLS-KDH message flow MUST use ECDH, and since
the keys MUST be ephemeral, the explicit form of the ClientECDiffieHellmanPublic
for the case ec_diffie_hellman [Section 5.7 of <xref target="RFC4492"/>] MUST
be used.</t>

</section>

<section title="CertificateVerify" anchor="certvfy">

<t>Under TLS-KDH, the CertificateVerify was preceded by a client's Ticket,
and the CertificateVerify MUST follow as a proof of posession of the
corresponding key material on the client.
This means that the
CertificateVerify message MUST follow the descriptions of a Kerberos Authenticator
<xref target="ext.krb.authsig"/> for use with TLS.</t>

<t>The Authenticator MUST be set to the client's cusec and ctime values,
and the server SHOULD validate these to fall within a reasonable margin
around the current time.</t>

<t>The subkey field MUST NOT be included in KDH-enhanced message flows.
In KDH-only message flows, the Authenticator MUST introduce a
new client-generated key in the subkey field, and the client MUST supply
at least the amount of entropy in the subkey
that is expected in the symmetric key produced by TLS under the selected
CipherSuite; the server SHOULD validate this subkey size to provide,
assuming optimal compression, at least the amount of entropy that is
desired for the CipherSuite's symmetric key.</t>

<t>For KDH-Only, the subkey is needed to form the pre-master secret on both
ends, which in turn influences the master secret.  Through the Finished
messages, the KDH-Only mode of operation performs mutual validation between
the client and server.</t>

</section>

<section title="Finished" anchor="finished">

<t>For KDH-enhanced flows, the server can be authenticated through its Certificate,
so that the usual Finished messages suffice, and TLS versions preceding 1.2 may
still suffice.</t>

<t>For KDH-only flows, the Finished
message is the first place where the server identity can be validated, prior to
reporting successful authentication to the application running atop TLS.
As a result, the KDH-only CipherSuites have been defined with an elongated
Finished message, for improved security.  This is possible since TLS 1.2.
The desired minimum length is defined with the introduction of the KDH-only
CipherSuite.</t>

</section>

</section>


<section title="Comparison to Earlier Work" anchor="comparison">

<t>An older specification <xref target="RFC2712"/> introduces Kerberos into TLS.
That specification is hereby deprecated because this new specification improves
on it work in a number of ways:
<list style="symbols">
<t>The premaster secret is no longer sent to the server under encryption with
the KDC-provided session key; instead, Forward Secrecy is
supported through ECDHE;</t>
<t>The authenticator following the Kerberos ticket is made obligatory, as
an intrinsic part of replay protection and the mutual authentication between
TLS client and TLS server to protect all in-transit application data;</t>
<t>There is no need to implement a replay cache, which means that more
efficient implementation is possible, certainly on highly active and/or
replicated TLS-KDH server systems;</t>
<t>The mutual authentication of TLS client and TLS server is established with
Kerberos-only CipherSuites that define a stronger Finished message size;</t>
<t>The service name is not statically set to the literal "host", but both
the client and server TLS stacks assume an application context to provide
the service name to be used;</t>
<t>The lack of forward secrecy in Kerberos is resolved by enforcing ECDH with any use of TLS-KDH;</t>
<t>The KDH-enhanced variation can be used with another mode of server
authentication.</t>
<t>Support for modern TLS CipherSuites is added,
and support for ones that are currently considered deprecated or insecure
have been removed;</t>
</list>
</t>

<t>Specifically for the HTTP and HTTPS protocols, the Negotiate header
<xref target="RFC4559"/>
can provide Kerberos authentication, but its use is not considered a strong
security practice.  Applications that currently rely on this mechanism can
strengthen their security if they
migrate to HTTP over TLS-KDH.  Note that this provides an alternative
for Kerberos, not to SPNEGO and not for general GSS-API protocols.  This
restriction of TLS-KDH to Kerberos, rather than a more general GSS-API protocol,
is a result of the fixed number of message exchanges available within TLS.</t>

<t>Many other protocols incorporate Kerberos through GSS-API, usually via SASL.
This is considered secure, but has an arguable disadvantage of separating encryption
and authentication layers, and quite possibly also the identities involved
in these layers.  Furthermore, encryption through SASL is not commonly used.
In situations where Kerberos is used for GSS-API over SASL, TLS-KDH offers
a comparable but more efficient and tighter-coupled mechanism for encryption and
mutual authentication, in a way that also lends itself to non-SASL applications.
Specifically useful in this respect is that there is no longer a requirement
to setup X.509 certificates plus infrastructure and validation mechanisms, just
to satisfy encryption requirements with their own authentication infrastructure.
In applications that use SASL, the EXTERNAL mechanism <xref target="RFC4422"/>
can use
the client identity in a Kerberos ticket, and make it available to the application
layer; SASL EXTERNAL is also commonly used when TLS authenticates peers through
X.509 certificates.</t>

<t>The use of additional Tickets for Backend Services
<xref target="tls.ext.backend"/>
replaces the paired practices "S4U2Self" and "S4U2Proxy", which
were not designed to crossover to hitherto unknown realms; they rely on the
service realm to constrain the use of rights granted over the client realm.  
Furthermore, said practices make use of hard-coded cryptographic algorithms,
which makes it impossible to assure their long-term security.</t>

</section>

<section title="Efficiency Considerations" anchor="efficiency">

<t>The efficiency of the mechanism described here compares favourably with
the more common approach of authentication through X.509 certificates
based on public-key algorithms.</t>

<t>The Kerberos architecture is founded on symmetric
cryptography, which makes it more efficient than the asymmetric architectures
around X.509 public-key certificates. Furthermore,
Kerberos' identity statements are short-lived, which is generally accepted to
evade the need for withdrawal mechanisms based on
chains of trust, CRLs <xref target="RFC3280"/>, OCSP <xref target="RFC6960"/>,
DANE <xref target="RFC6698"/>
and perhaps other mechanisms. As a result, the validity of
a Kerberos ticket can be checked with relatively modest computational effort.</t>

<t>The inclusion of ephemeral ECDH is a relatively expensive
asymmetric operation, but the same introduction is needed when
Forward Secrecy is introduced alongside public-key authentication.</t>

<t>The one thing that is costly about Kerberos is its reliance on a replay
cache.  Such caches store recent authentication attempts to avoid that
they are being replayed; an accurate clock helps to release entries, but
some care for clock skew between TLS-KDH client and server must be resolved
with these caches.  Their volatile nature makes them a particularly difficult
problem in highly active and/or replicated and/or distributed Kerberos
services.</t>

<t>A replay cache is not required for any of the TLS-KDH protocol flows,
because this specification requires an ephemeral ECDH key exchange.  This is of
particular use to redundant (and possibly distributed) server farms, where
sharing the time-critical information of the replay cache is a performance
bottle neck.  Since
this is a new specification, there is no need to implement backward
compatibility with older mechanisms for which a replay cache might be needed.</t>

</section>

<section title="Privacy Considerations" anchor="privacy">

<t>The information that is publicly shown in the TLS-KDH protocol flows consists of:
<list style="symbols">
<t>Supported protocol versions, TLS extensions and CipherSuites</t>
<t>For other than Kerberos-only CipherSuites, the server's Certificate</t>
<t>The server's principal name, host name and service name</t>
</list>
</t>

<t>A Kerberos ticket transmits less information in plaintext than a public-key X.509 client
certificate; furthermore, DNS may have to reveal the realm name(s) of server-trusted
KDC(s) but neither the TLS-KDH server nor any KDC publishes long-lasting
key material for TLS or Kerberos, so parties looking for a cracking challenge are
constrained to a brief period of attack on keys.</t>

<t>The TicketRequestFlags may provide information about Tickets present in
the client, but that would take the risk of leaking information prior to
authentication of the server, and in plaintext.</t>

</section>


<section title="Security Considerations" anchor="security">

<t>For KDH-enhanced message flows, the server can be authenticated through
its public-key X.509 Certificate.  For KDH-onnly message flows this is not possible,
which is why a longer verify_data_size in the Finished messages is required;
the ability to generate these messages properly proves that the other side
has succeeded in decrypting the Kerberos-encrypted materials, and so, that it is
the intended remote party.</t>

<t>In Kerberos, all key material is supplied by the KDC. This is a central
point in each realm that is usually guarded well enough, but it is
nonetheless a critical point in any infrastructure founded on Kerberos.
When client and server are in different realms, but have cross-signed
directly or through a chain of KDCâ€™s, then all intermediate KDCâ€™s are
potential places where the session key could be detected. The weakest KDC
in the chain then defines the security of the entire chain.</t>

<t>Kerberos requires accurate clocks in order to operate securely; without
them, once-used and since-forgotten credentials could be replayed by an
attacker that has been able to recover an old service ticketâ€™s session
key. This problem is worsened in cross-realm scenarioâ€™s where clock
synchronisation is hard to realise.  This is however resolved in all TLS-KDH
flows by using ephemeral Elliptic-Curve Diffie-Hellman keys, thus
forcing new master secrets on each connection and removing the need for
a replay buffer.  Note however, that ticket validity times must still be
checked.</t>

<t>Basic Kerberos security hinges on the secrecy of the user's password;
if this password is guessed, then all captured traffic can be decoded,
even in retrospect.
This means that it is highly advisable to combine Kerberos with
Diffie-Hellman for Forward Secrecy. TLS-KDH implies this desirable
property in all its CipherSuites.</t>

</section>

<section title="IANA Considerations" anchor="iana">

<!-- Standards Action or Expert Review: -->
<t>IANA adds the following Kerberos Checksum Type Numbers to the
Kerberos Parameters registry, to match the hash algorithms
available to TLS:</t>
<texttable>
<ttcol align="left">sumtype value</ttcol>
<ttcol align="left">Checksum type</ttcol>
<ttcol align="left">checksum size</ttcol>
<c>TBD</c><c>sha224 (unkeyed)</c><c>28</c>
<c>TBD</c><c>sha256 (unkeyed)</c><c>32</c>
<c>TBD</c><c>sha384 (unkeyed)</c><c>48</c>
<c>TBD</c><c>sha512 (unkeyed)</c><c>64</c>
</texttable>

<!-- Anarchy... -->
<t>Through the IETF Kitten WG, the Kerberos community assigns the following value
for the AuthorizationData type for backend tickets, as defined in this
specification:</t>
<texttable>
<ttcol align="left">Value</ttcol>
<ttcol align="left">Name</ttcol>
<c>TBD</c><c>AD-BACKEND-TICKETS</c>
</texttable>

<!-- <t>KDC_ERR_INCOMPLETE_BACKEND_TICKETS</t> -->
<!-- <t>TD-REQUIRED-BACKEND-TICKETS</t> -->

<!-- Standards Action or Specification Required: -->
<t>IANA adds the following entries to the TLS Cipher Suite Registry underneath
the TLS Paramters registry, to enable KDH-only negotiation and the Kerberos-Only
profile that relies on it:</t>
<texttable>
<ttcol align="left">Value</ttcol>
<ttcol align="left">Description (verify_data_length)</ttcol>
<ttcol align="left">DTLS-OK</ttcol>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_AES_128_GCM_SHA256 (32)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_AES_256_GCM_SHA384 (48)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_AES_256_GCM_SHA512 (64)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_AES_128_CCM (32)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_AES_256_CCM (48)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_AES_128_CCM_8 (32)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_AES_256_CCM_8 (48)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_CAMELLIA_128_GCM_SHA256 (32)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_CAMELLIA_256_GCM_SHA384 (48)</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KDH_WITH_CAMELLIA_256_GCM_SHA512 (64)</c><c>Y</c>

</texttable>

<!-- Standards Action or Specification Required: -->
<t>IANA adds the following ClientCertificateType Identifier to the
TLS Parameters registry, to be able to formule certificate requests
under TLS-KDH as described in this document:</t>
<texttable>
<ttcol align="left">Value</ttcol>
<ttcol align="left">Description</ttcol>
<ttcol align="left">DTLS-OK</ttcol>
<c>TBD</c><c>kerberos_sign</c><c>Y</c>
</texttable>

<!-- Standards Action or Specification Required: -->
<t>IANA adds the following TLS SignatureAlgorithm to the
TLS Parameters registry, to permit the Kerberos-based signatures described in
this document:</t>
<texttable>
<ttcol align="left">Value</ttcol>
<ttcol align="left">Description</ttcol>
<ttcol align="left">DTLS-OK</ttcol>
<c>TBD</c><c>kerberos</c><c>Y</c>
</texttable>

<!-- RFC Required (of any kind): -->
<t>IANA adds the following TLS Certificate Type to the
TLS Extensions registry, to support negotiating it as a client_certificate_type
and possibly as a server_certificate_type:</t>
<texttable>
<ttcol align="left">Value</ttcol>
<ttcol align="left">Description</ttcol>
<ttcol align="left">DTLS-OK</ttcol>
<c>TBD</c><c>KerberosTicket</c><c>Y</c>
</texttable>

<!-- IETF Consensus, but intended to be relaxed under TLS 1.3: -->
<t>IANA adds the following ExtensionType Value to the
TLS Extensions registry, to support the negotiation of TicketRequestFlags as
described in this specification:</t>
<texttable>
<ttcol align="left">Value</ttcol>
<ttcol align="left">Extension Name</ttcol>
<c>TBD</c><c>TicketRequestFlags</c>
</texttable>

<!-- Only form constraints: -->
<t>IANA appends a new "TLS-KDH Ticket Request Flags" sub-register to the
TLS Extensions register, to support the allocation of TicketRequestFlags by
other specifications.
New entries to this table can be made under the named Assignment Policy
<xref target="RFC5226"/>.
The initial entries to this registry are:</t>
<texttable>
<ttcol align="left">Value(s)</ttcol>
<ttcol align="left">Name</ttcol>
<ttcol align="left">Reference</ttcol>
<ttcol align="left">Assignment Policy</ttcol>
<c>0..31</c><c>TicketFlags</c><c>TBD:THISSPEC</c><c>RFC Required</c>
<c>32</c><c>VisibleClientRealm</c><c>TBD:THISSPEC</c><c>RFC Required</c>
<c>33</c><c>UniqueClientIdentity</c><c>TBD:THISSPEC</c><c>RFC Required</c>
<c>34</c><c>LastingClientIdentity</c><c>TBD:THISSPEC</c><c>RFC Required</c>
<c>35..63</c><c>Unassigned</c><c> </c><c>RFC Required</c>
<c>64..79</c><c>Private Use</c><c>N/A</c><c>Private Use</c>
<c>80..95</c><c>Experimental</c><c>N/A</c><c>Experimental Use</c>
<c>96..</c><c>Reserved</c><c> </c><c>RFC Required</c>
</texttable>

<!--
<t>This specification defines a number of CipherSuites that use Kerberos with
Diffie-Hellman subkeys as their authentication mechanism.  These define the
initial list of what is referred to as "TLS-KDH CipherSuites" in this
specification:</t>

<texttable>
<ttcol align="left">Value</ttcol>
<ttcol align="left">CipherSuite description</ttcol>
<ttcol align="left">verify_data_length</ttcol>
<ttcol align="left">DTLS-OK</ttcol>
< ! - - REMOVED <c>TBD</c><c>TLS_DHE_KRB_WITH_3DES_EDE_CBC_SHA</c><c>21</c><c>Y</c> - - >
<c>TBD</c><c>TLS_DHE_KRB_WITH_IDEA_CBC_SHA</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_128_CBC_SHA</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_256_CBC_SHA</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_128_CBC_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_256_CBC_SHA384</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_256_CBC_SHA256</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_128_GCM_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_256_GCM_SHA384</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_CAMELLIA_128_CBC_SHA</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_CAMELLIA_256_CBC_SHA</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_CAMELLIA_128_CBC_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_CAMELLIA_256_CBC_SHA256</c><c>32</c><c>Y</c>
< ! - - REMOVED <c>TBD</c><c>TLS_DHE_KRB_WITH_SEED_CBC_SHA</c><c>16</c><c>Y</c> - - >
<c>TBD</c><c>TLS_DHE_KRB_WITH_ARIA_128_CBC_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_ARIA_256_CBC_SHA384</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_ARIA_128_GCM_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_ARIA_256_GCM_SHA384</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_128_CCM</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_256_CCM</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_128_CCM_8</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_DHE_KRB_WITH_AES_256_CCM_8</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_CAMELLIA_128_GCM_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_CAMELLIA_256_GCM_SHA384</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_AES_128_CCM</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_AES_256_CCM</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_AES_128_CCM_8</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_AES_256_CCM_8</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_AES_128_GCM_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_AES_256_GCM_SHA384</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_CAMELLIA_128_CBC_SHA</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_CAMELLIA_256_CBC_SHA</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_CAMELLIA_128_CBC_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_CAMELLIA_256_CBC_SHA256</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_ARIA_128_CBC_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_ARIA_256_CBC_SHA384</c><c>32</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_ARIA_128_GCM_SHA256</c><c>16</c><c>Y</c>
<c>TBD</c><c>TLS_ECDHE_KRB_WITH_ARIA_256_GCM_SHA384</c><c>32</c><c>Y</c>
</texttable>

<t>[TODO: 3DES_EDE_CBC is not included anymore]</t>

<t>[TODO: SEED does not seem to get updates, so it is not included here]</t>

<t>[TODO: Should we still define 160-bit _SHA CipherSuites?]</t>

<t>[TODO: Should we still define CBC encryption modes?  They'll probably be removed in TLS 1.3 anyway.  BEAST attacks TLS &lt; 1.1 so that is not an issue here; Lucky 13 probably applies.]</t>

<t>[TODO: MIT suggests dropping DHE and just to support ECDHE in <xref target="KRB5-KDH"/>; the same would apply here.]</t>
-->

<!-- **BEGIN.NOTES**

-    Perhaps pipe the IANA list through grep | sed | sort | uniq?

cat /tmp/ciphersuites.txt | grep 'TLS_\(EC\)\?DHE_' | grep -v '_KRB_' | sed -e 's/_RSA_/_KRB_/' -e 's/_DSS_/_KRB_/' -e 's/_PSK_/_KRB_/' -e 's/_ECDSA_/_KRB_/' | grep '_KRB_' | sort | uniq | grep -v _NULL_ | grep -v _EXPORT_ | grep -v '_RC4_' | grep -v '_DES_'


-   TLS_DHE_KRB_WITH_3DES_EDE_CBC_SHA
-   TLS_DHE_KRB_WITH_AES_128_CBC_SHA
-   TLS_DHE_KRB_WITH_AES_128_CBC_SHA256
-   TLS_DHE_KRB_WITH_AES_128_CCM
-   TLS_DHE_KRB_WITH_AES_128_CCM_8
-   TLS_DHE_KRB_WITH_AES_128_GCM_SHA256
-   TLS_DHE_KRB_WITH_AES_256_CBC_SHA
-   TLS_DHE_KRB_WITH_AES_256_CBC_SHA256
-   TLS_DHE_KRB_WITH_AES_256_CBC_SHA384
-   TLS_DHE_KRB_WITH_AES_256_CBC_SHA512
-   TLS_DHE_KRB_WITH_AES_256_CCM
-   TLS_DHE_KRB_WITH_AES_256_CCM_8
-   TLS_DHE_KRB_WITH_AES_256_GCM_SHA384
-   TLS_DHE_KRB_WITH_AES_256_GCM_SHA512
-   TLS_DHE_KRB_WITH_ARIA_128_CBC_SHA256
-   TLS_DHE_KRB_WITH_ARIA_128_GCM_SHA256
-   TLS_DHE_KRB_WITH_ARIA_256_CBC_SHA384
-   TLS_DHE_KRB_WITH_ARIA_256_CBC_SHA512
-   TLS_DHE_KRB_WITH_ARIA_256_GCM_SHA384
-   TLS_DHE_KRB_WITH_ARIA_256_GCM_SHA512
-   TLS_DHE_KRB_WITH_CAMELLIA_128_CBC_SHA
-   TLS_DHE_KRB_WITH_CAMELLIA_128_CBC_SHA256
-   TLS_DHE_KRB_WITH_CAMELLIA_128_GCM_SHA256
-   TLS_DHE_KRB_WITH_CAMELLIA_256_CBC_SHA
-   TLS_DHE_KRB_WITH_CAMELLIA_256_CBC_SHA256
-   TLS_DHE_KRB_WITH_CAMELLIA_256_CBC_SHA384
-   TLS_DHE_KRB_WITH_CAMELLIA_256_CBC_SHA512
-   TLS_DHE_KRB_WITH_CAMELLIA_256_GCM_SHA384
-   TLS_DHE_KRB_WITH_CAMELLIA_256_GCM_SHA512
-   TLS_DHE_KRB_WITH_SEED_CBC_SHA
-   TLS_ECDHE_KRB_WITH_3DES_EDE_CBC_SHA
-   TLS_ECDHE_KRB_WITH_AES_128_CBC_SHA
-   TLS_ECDHE_KRB_WITH_AES_128_CBC_SHA256
-   TLS_ECDHE_KRB_WITH_AES_128_CCM
-   TLS_ECDHE_KRB_WITH_AES_128_CCM_8
-   TLS_ECDHE_KRB_WITH_AES_128_GCM_SHA256
-   TLS_ECDHE_KRB_WITH_AES_256_CBC_SHA
-   TLS_ECDHE_KRB_WITH_AES_256_CBC_SHA384
-   TLS_ECDHE_KRB_WITH_AES_256_CBC_SHA512
-   TLS_ECDHE_KRB_WITH_AES_256_CCM
-   TLS_ECDHE_KRB_WITH_AES_256_CCM_8
-   TLS_ECDHE_KRB_WITH_AES_256_GCM_SHA384
-   TLS_ECDHE_KRB_WITH_AES_256_GCM_SHA512
-   TLS_ECDHE_KRB_WITH_ARIA_128_CBC_SHA256
-   TLS_ECDHE_KRB_WITH_ARIA_128_GCM_SHA256
-   TLS_ECDHE_KRB_WITH_ARIA_256_CBC_SHA384
-   TLS_ECDHE_KRB_WITH_ARIA_256_CBC_SHA512
-   TLS_ECDHE_KRB_WITH_ARIA_256_GCM_SHA384
-   TLS_ECDHE_KRB_WITH_ARIA_256_GCM_SHA512
-   TLS_ECDHE_KRB_WITH_CAMELLIA_128_CBC_SHA256
-   TLS_ECDHE_KRB_WITH_CAMELLIA_128_GCM_SHA256
-   TLS_ECDHE_KRB_WITH_CAMELLIA_256_CBC_SHA384
-   TLS_ECDHE_KRB_WITH_CAMELLIA_256_CBC_SHA512
-   TLS_ECDHE_KRB_WITH_CAMELLIA_256_GCM_SHA384
-   TLS_ECDHE_KRB_WITH_CAMELLIA_256_GCM_SHA512


**END.NOTES** -->

</section>

</middle>


<back>

<references title="Normative References">

<!--
<reference anchor='KRB5-KDH'>
<front>
<title abbrev="krb5-kdh">KRB5-KDH: Cryptographically binding Kerberos with Diffie-Hellman</title>
<author initials="R" surname="Van Rein" fullname="Rick van Rein">
<organization>InternetWide.org</organization>
<address>
<postal><street>Haarlebrink 5</street><city>Enschede</city><region>Overijssel</region><code>7544 WP</code><country>The Netherlands</country></postal>
<email>rick@openfortress.nl</email>
</address>
</author>
<date day="11" month="October" year="2014"/>
<abstract>
<t>This specification extends Kerberos with primitives that create a
cryptographic binding between Kerberos authentication and
Diffie-Hellman encryption. This yields their combined advantages.</t>
</abstract>
</front>
</reference>
-->

<!-- DROPPED AS OUT-OF-SCOPE REFERENCE
<reference anchor='KREALM'>
<front>
<title abbrev="krealm">Declaring Kerberos Realm Names in DNS (_kerberos TXT)</title>
<author initials="R" surname="Van Rein" fullname="Rick van Rein">
<organization>InternetWide.org</organization>
<address>
<postal><street>Haarlebrink 5</street><city>Enschede</city><region>Overijssel</region><code>7544 WP</code><country>The Netherlands</country></postal>
<email>rick@openfortress.nl</email>
</address>
</author>
<date day="11" month="September" year="2015"/>
<abstract>
<t>This specification defines methods to determine Kerberos realm
   descriptive information for services that are known by their DNS
   name.  Currently, finding such information is done through static
   mappings or educated guessing.  DNS can make this process more
   dynamic, provided that DNSSEC is used to ensure authenticity of
   resource records.</t>
</abstract>
</front>
</reference>
-->

<!-- EXTERNAL <?rfc include="reference.RFC.1035.xml"?> -->
<?rfc include="reference.RFC.1510.xml"?>
<!-- EXTERNAL <?rfc include="reference.RFC.4033.xml"?> -->
<!-- <?rfc include="reference.RFC.2782.xml"?> -->
<?rfc include="reference.RFC.4120.xml"?>
<?rfc include="reference.RFC.4343.xml"?>
<?rfc include="reference.RFC.4492.xml"?>
<?rfc include="reference.RFC.5226.xml"?>
<?rfc include="reference.RFC.5246.xml"?>
<!-- <?rfc include="reference.RFC.5280.xml"?> -->
<!-- <?rfc include="reference.RFC.5746.xml"?> -->
<!-- <?rfc include="reference.RFC.6066.xml"?> -->
<!-- <?rfc include="reference.RFC.6806.xml"?> -->
<?rfc include="reference.RFC.6112.xml"?>
<?rfc include="reference.RFC.7250.xml"?>
<?rfc include="reference.RFC.7627.xml"?>

</references>

<references title="Informative References">

<!--
<reference anchor='DNSTXT-KRB1'>
<front>
<title abbrev="DNS TXT &quot;v=krb1&quot;">Finding the Kerberos Realm of a Service in DNS</title>
<author initials="R" surname="Van Rein" fullname="Rick van Rein">
<organization>ARPA2.net</organization>
<address>
<postal>
<street>Haarlebrink 5</street>
<city>Enschede</city>
<region>Overijssel</region>
<code>7544 WP</code>
<country>The Netherlands</country>
</postal>
<email>rick@openfortress.nl</email>
</address>
</author>
<date day="19" month="October" year="2014"/>
<abstract>
<t>This specification defines methods to determine realm names 
for services being contacted by their DNS name.  Currently,
finding realm names is done through guessing or local configuration.
DNS can make this process more dynamic, provided that DNSSEC is used
to ensure authenticity of resource records.</t>
</abstract>
</front>
</reference>
-->

<?rfc include="reference.RFC.2712.xml"?>
<?rfc include="reference.RFC.3280.xml"?>
<?rfc include="reference.RFC.4422.xml"?>
<?rfc include="reference.RFC.4559.xml"?>
<!-- <?rfc include="reference.RFC.5801.xml"?> -->
<!-- DTLS: <?rfc include="reference.RFC.6347.xml"?> -->
<?rfc include="reference.RFC.6698.xml"?>
<?rfc include="reference.RFC.6960.xml"?>
<?rfc include="reference.RFC.7542.xml"?>

</references>

<section title="Acknowledgements" anchor="ack">

<t>This specification could not have matured without the insights of various
commenters.  In order of appearance, we owe thanks to Simo Sorce,
Ilari Liusvaara, Watson Ladd, Benjamin Kaduk, Nikos Mavragiannopoulos.
Special thanks go to Tom Vrancken for tracking the development of the
specification, commenting on it and implementing it in GnuTLS.</t>

<t>This work was conducted under a grant from the programme "[veilig] door
innovatie" from the government of the Netherlands.  It has also
been liberally supported by the NLnet Foundation.</t>

</section>

</back>

</rfc>
