<?xml version="1.0"?>
<?xml-stylesheet type="text/xsl" href="rfc2629.xslt"?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes" ?>
<?rfc compact="yes" ?>
<?rfc symrefs="yes" ?>
<?rfc subcompact="no" ?>
<?rfc comments="yes" ?>
<?rfc inline="yes" ?>

<rfc ipr="trust200902" docName="draft-vanrein-tls-kdh-06" category="std">

<front>

	<title abbrev="TLS-KDH">Quantum Relief with TLS and Kerberos</title>

	<author initials="R" surname="Van Rein" fullname="Rick van Rein">
		<!-- <organization>OpenFortress B.V.</organization> -->
		<organization>InternetWide.org</organization>
		<address>
			<postal>
				<street>Haarlebrink 5</street>
				<city>Enschede</city>
				<region>Overijssel</region>
				<code>7544 WP</code>
				<country>The Netherlands</country>
			</postal>
			<email>rick@openfortress.nl</email>
		</address>
	</author>

	<author initials="T" surname="Vrancken" fullname="Tom Vrancken">
		<!-- <organization>OpenFortress B.V.</organization> -->
		<organization>InternetWide.org</organization>
		<address>
			<postal>
				<street>TBD:WHICH</street>
				<city>Eindhoven</city>
				<region>Noord-Brabant</region>
				<code>TBD:WHICH</code>
				<country>The Netherlands</country>
			</postal>
			<email>tom.vrancken@arpa2.org</email>
		</address>
	</author>

	<date day="16" month="August" year="2091"/>

	<abstract>
		<t>This specification describes a mechanism to use Kerberos
		authentication within the TLS protocol. This gives users of TLS a
		strong alternative to classic PKI-based authentication, and at the same
		introduces a way to insert entropy into TLS' key schedule such that
		the resulting protocol becomes resistant against attacks from quantum
		computers. We call this Quantum Relief, and specify it as part of a more
		general framework to make it easier for other technologies to achieve
		similar benefits.</t>
<!-- kan niet, standards track: Deprecate RFC2712 -->
	</abstract>

<!--

CHANGES FROM 05 TO 06:
 *

RESTARTING IN 05:
 * Moving on to TLS 1.3 (was TLS 1.2)
 * Central theme for Quantum Relief
 * Use of an Extension to negotiate encryption alone
 * Use of Certificate Types for client and server Certificate/Verify
 * Backport the approach to TLS 1.2
 * Many suggestions from Tom Vrancken (fully validating him as co-author)

CHANGES FROM 04 TO UNPUBLISHED 05:
* Showed CAMELLIA-based Cipher Suites in the IANA Considerations as well
* Remarks about post-quantum cryptography
* Done: Consider to drop TicketRequestFlags
* Done: Consider passing additional tickets through authzdata; notify needs too?
* Done: How secure is it to let the server submit its TGT?  Does KDC check enough?

CHANGES FROM 03 TO 04:
* Forbidden KDH-Enhanced with subkey in Authenticator; required it in KDH-Only
* For KDH-Only pre-master secret ignore Ticket, but hash entire Authenticator
* Re-added CAMELLIA128/256/256-based CipherSuites with GCM and SHA256/384/512
* Server Certificate sent in KDH-Only, maybe empty, as with Client Certificate
* Added 512-bit CipherSuites
* Merged "Related Work" into "Comparison to Earlier Work"
* Added deprecation of RFC 2712 (to abstract as textual to-do)
* Wrote Acknowledgements section
* Redefined backend tickets, and removed questioning it
* Ticket length 0 marks refusal to provide a ticket

CHANGES FROM 02 TO 03:
* No longer dependent on exchange of TicketRequestFlags to detect/allow TLS-KDH
* Changed to KerberosTicket as client_certificate_type, RFC 7250
* Enabled a  KerberosTicket as server_certificate_type for user-to-user KDH-only
* Server may choose any server_certificate_type it likes when KDH-enhanced
* Wrote the IANA Considerations section

CHANGES FROM 01 TO 02:
* Simplified the wire representation of TicketRequestFlags
* Added conceptual data per connection: TicketRequestFlags, possibly KDH-only/-enhanced

CHANGES FROM 00 TO 01:
* Taken out protocol-bound DH; this saves about 75% of the complexity
* Pre-master secret now incorporates Kerberos session key and DH shared secret
* Integration with "normal" X.509 certificates; client may use krb5 certificate
* Kerberos Ticket as X.509 pubkeyinfo; Authenticator as signature mechanism
* Define TLS-standardised hashes as ChecksumTypes for use in an Authenticator
* Moved TicketRequestFlags to a TLS Extension; negotiation with min/max flags
* Added descriptions of how to support backend servers in Ticket AuthData

-->

</front>

<middle>

<section title="Introduction" anchor="intro">

<t>TLS protects many application protocols from many security problems.  To
enable this, it habitually relies on public-key cryptography.  But in the
foreseeable future, quantum computers are expected to destroy these public-key
underpinnings.  This endangers TLS, because encrypted data may be captured and stored, ready for decryption as soon as quantum computers hit the playing field.</t>

<t>Most present-day applications of TLS are threatened by quantum computers; some may not be able to live up to legal requirements for long-term encryption.  There even is a risk of future power imbalances between those who have a quantum computer and those who have not.</t>

<t>The solution is to not rely solely on public-key cryptography, but instead mix in secret entropy that a future quantum computing entity cannot decipher.  In this light, Kerberos offers an interesting perspective, as it builds a symmetric-key infrastructure including cross-realm connectivity options.  Kerberos is considered safe from quantum computers, as long as its public-key extensions are avoided.</t>

<t>We therefore specify a quantum_relief extension that mixes secret entropy
from another source into the TLS key computations. This concrete mechanism,
which relies on Kerberos for relief against quantum computing and on
(Elliptic-Curve) Diffie-Hellman for Perfect Forward Secrecy (and to stop the
sphere of influence of the KDC administrator), shall be referred to as Kerberised Diffie-Hellman or KDH.  A definition is included for a KDH-Only Application Profile, to facilitate small and simple implementations.</t>

</section>

<section title="Quantum Relief as a General Mechanism" anchor="qr">

<t>The PSK mechanism in TLS 1.3 and 1.2 allows insertion of key material which is referenced by name alone.  A naming system is defined, but its interpretation resides under local policy, which is enough for internal use cases, but it is insufficient for general use between any two parties.</t>

<t>Cryptographically however, the entropy from the PSK mechanism in TLS 1.3 is
secret to external observers, and mixed with the DHE material using a series of
HKDF-Extract and -Expand operations [<xref target="RFC5869"/>].  When used on their own, the DHE material can be reversed by quantum computers and any subsequent HKDF computations redone, uncovering the complete key schedule of TLS.  The extra source of entropy inserted for a PSK however, will have to be uncovered separately, and this may not be possible in all cases.</t>

<t>This specification therefore defines a quantum_relief extension that
replaces the locally useful PSK scheme with a generally usable mechanism for
the insertion of secret entropy into the TLS 1.3 key schedule at the position
otherwise used by the PSK; this sacrifices support for 0-RTT data in TLS 1.3.
In TLS 1.2, an intermediate phase during the computation of the master secret
inserts the extra entropy.</t>

<t>In order to provide sufficient quantum relief the added entropy must meet
the following conditions:
<list style="symbols" hangIndent="6">
<t>The amount of entropy must on its own suffice for the security level of the TLS connection.</t>
<t>The entropy must be secret, meaning invisible for outside observers.</t>
<t>Only quantum-proof mechanisms should be used for the generation of the entropy.</t>
</list></t>

<t>In terms of algorithms that are commonplace today, the third requirement is generally believed to be met by secure hashes and symmetric encryption.  The problem with these is sharing random information secretely and at the same time controlling who has access to these secrets.</t>
</section>

<section title="TLS-KDH for Quantum Relief through Kerberos" anchor="tls-kdh">

<t>TLS-KDH is designed to provide two things; (1) an alternative to X.509 PKI
authentication, (2) Quantum Relief TLS connections.</t>

<t>The infrastructure of Kerberos provides a good balance between the requirements for a Quantum Relief mechanism, as a result of key derivation to hierarchical expansion of locally controlled secrets.</t>

<t>In the TLS 1.3 key schedule, the quantum_relief extension replaces the input from a PSK; the two extensions are not considered useful when combined.
In TLS 1.2, a similar result is achieved by enhancing the pre-master secret independently of the negotiated cipher suite.</t>

<t>In addition to Quantum Relief, TLS-KDH can offer authentication based on
Kerberos tickets.  This introduces new facilities into TLS, such as deferred
authentication, anonymous realm users and centralised facilitation of realm
crossover.</t>

<section title="Injecting Kerberos-derived Entropy">
<t>Whether a Ticket is supplied in the ClientHello or returned by a responding peer
in the ServerHello, it yields a key only known to the two connecting parties.  This key is used in standard Kerberos encryption of the concatenated random data from ClientHello and ServerHello.  This means that both parties influence the entropy gathered and can derive a sequence of bytes that is invisible to anyone else.  The output from the encryption operation is plugged into the key schedule instead of the PSK input parameter.  This input is designed for this kind of loose entropy of arbitrary size.</t>
</section>

<section title="Client-to-Server Flow" anchor="kdh-c2s">
<t>The flow of TLS 1.3 works best when encryption is provided early, and
authentication is provided late.  These aspects are often combined in Kerberos,
but KDH splits them to resemble TLS patterns more closely, and
offer almost-orthogonal Kerberos versions for (1) additional secret entropy for encryption, (2) client authentication through Kerberos Tickets and (3) server authentication through Kerberos Tickets.  Only (1) provides Quantum Relief.  The server cannot initiate Kerberos, so (3) is not possible without (1).</t>

<t>The TLS-KDH flow
uses ClientHello and ServerHello for a Kerberos-protected exchange of entropy,
but it completely ignores the client identity during this phase.  This allows clients to use an anonymous Ticket in the ClientHello message and consider authenticating with an identifying Ticket in later client Certificate and CertificateVerify messages.</t>

<t>Server identity however, is observed in all Tickets, so any use of the Ticket’s contained key by the server suffices as proof of its identity.  This renders the server Certificate and CertificateVerify messages redundant if the server accepts the KDH extension, especially in TLS 1.3 because the Finished message follows immediately.  But redundancy can be a feature; it is certainly legitimate to still authenticate the server with an explicit Kerberos Ticket, X.509 certificate or other.</t>

<t>When the server desires proof of client identity, it sends a CertificateRequest.  KDH introduces a certificate type for a Kerberos Ticket, relying on a Kerberos Authenticator as CertificateVerify message.  The server is also able to use this to prove being able to use a supplied Ticket with its identity.</t>
</section>

<section title="Peer-to-Peer Flow" anchor="kdh-p2p">

<t>Besides the customary client-to-server flow there is also support for a peer-to-peer flow in TLS-KDH.  When this is used, the ClientHello sent to a TLS serverby an initiating peer requests a responding peer identity and sends a TGT.  This client may use an anonymous name for itself.</t>

<t>Without documenting it here, the TLS server is assumed to have some method of locating a responding peer and proxying the entire TLS connection to its endpoint.  The only service performed by the TLS server is relaying the literal TLS connection between the initiating client/peer and this responding peer.  The TLS server is not involved in cryptographic computations for the TLS connection.</t>

<t>The responding peer returns in its ServerHello a Ticket based on the TGT, obtained through the user-to-user flow of Kerberos.  This return Ticket will reverse the client and server role for Kerberos, but for peer-to-peer connectivity that does not matter.  The responding peer will authenticate itself to the initiating peer through its use of this return Ticket and it can decide whether authentication of the initiating client is desired.  When the client would authenticate through a Kerberos Ticket, this would follow the client and server roles of Kerberos; as before, for peer-to-peer traffic this should not be problematic, even if it imposes a requirement on cross-realm connections that they must be bidirectional.</t>

</section>

</section>

<section title="New Data Types and Procedures">

<t>The following data structures are introduced to define the Quantum Relief
mechanism for TLS 1.3 and 1.2. Additionally, specific values and procedures are
defined for the TLS-KDH mechanism that implements one specific form of quantum
relief for TLS.</t>

<section title="Quantum Relief Extension">

<t>This section defines a new TLS extension called quantum_relief that
enables quantum relief for TLS as defined in <xref target="qr"/>. The extension is
designed such that it can be applied generically. As a concrete quantum
relief implementation we herein define how this exentions must be used for
TLS-KDH [<xref target="tls-kdh"/>]. Future mechanisms may extend this definition.</t>

<t>In order to distinguish between different Quantum Relief methods a
QuantumReliefMethod tag is defined to set KDH aside from possible future
forms which, to be eligable, MUST assure they meet the conditions for providing
proper entropy [<xref target="qr"/>].</t>

<figure><artwork><![CDATA[
enum {
    kdh(0),
    (65535)
} QuantumReliefMethod;
]]></artwork></figure>

<t>The value "kdh" is always used for the method of Quantum Relief proposed
herein, which is based on Kerberos.</t>

<t>A TLS ClientHello can additionally specify a name for a peer that it
wants to respond, for
which various application-independent forms may be anticipated. This is
captured in yet another tag PeerNameType, of which only a type for unencrypted
Kerberos names is currently defined (i.e. krb5princrealm).</t>

<figure><artwork><![CDATA[
enum {
    none(0),
    krb5princrealm(1),
    (65535)
} PeerNameType;
]]></artwork></figure>

<t>The value "none" is used for standard client-to-server TLS connections.  The value "krb5princrealm" is used in a ClientHello to indicate a Kerberos PrincipalName and Realm [Section 5.2.2 of <xref target="RFC4120"/>] for the responding peer sought behind the TLS server.</t>

<t>The Quantum Relief Extension is now defined as follows:</t>

<figure><artwork><![CDATA[
struct {
    PeerNameType peernametype;
    select (peernametype) {
        case none:
            /* No peer name type */
            Empty;
        case krb5princrealm:
            /* PrincipalName and Realm, resp. */
            struct {
                opaque krb5princ<3..1023>;
                opaque krb5realm<3..1023>;
            } krb5PrincipalRealm;
    }
    QuantumReliefMethod qh_method;
    select (qh_method) {
        case kdh:
            /* Empty, ticket or TGT */
            opaque opt_ticket<0..65535>;
    }
} QuantumRelief;
]]></artwork></figure>

<t>This structure is used as extension_data corresponding to the
quantum_relief extension_type, registered by IANA under number
TBD:QREXTTYPE, to occur only during ClientHello and ServerHello (i.e. CH and
SH according to https://tools.ietf.org/html/rfc8446#section-4.2).  IANA also
created registries for the QuantumReliefMethod and PeerNameType in their
TBD:TLSExtensionsRegistry.</t>

</section>

<section title="Ticket-based Encryption Procedure">

<t>The TLS-KDH messages and cryptographic computations require the use of the key concealed in a Ticket to produce a binary object that cryptographically binds its input to the key.  It is variably used as a source of entropy and as proof, but it is always obtained through a standard encryption procedure for Kerberos.</t>

<figure><artwork><![CDATA[
Signature:
 o = Ticket-Encrypt (t, u, h)

Input:
 - Ticket t
 - KeyUsage u
 - Hash h

Output:
 - OctetString o

Steps:
 1. base-key     = t.enc-part.key
 2. specific-key = rfc3961.key-derivation (base-key, u)
 3. init-state   = rfc3961.initial-cipher-state (
                   specific-key, DIRECTION_ENCRYPT)
 4. (state,o)    = rfc3961.encrypt (specific-key, init-state)
]]></artwork></figure>

<t>Not shown in the procedure, there is a need to decrypt the enc-part of the Ticket before the key concealed in it can be extracted.  This is where proof of identity comes into play; only the two parties connected by the Ticket should be able to perform this decryption.</t>

<t>The name prefix "rfc3961" points to the generic descriptions for Kerberos
key-based procedures <xref target="RFC3961"/> that are implemented with various
algorithms.  Available algorithms are listed in the IANA Registry of Kerberos
Parameters.</t>

<t>The Key Usage values are numbers, for which the following are defined by this specification.  Their number ranges are deliberately chosen to not clash with those of Kerberos, but otherwise compliant to the application range [Section 7.5.1 of <xref target="RFC4120"/>].  The Key Usage values are referenced by name elsewhere in this specification.</t>

<figure><artwork><![CDATA[
2008 = KEYUSAGE_TLS12KDH_PREMASTER_QH
2018 = KEYUSAGE_TLSKDH_CLIENT_QH
2019 = KEYUSAGE_TLSKDH_SERVER_QH
2020 = KEYUSAGE_TLSKDH_SERVER_VFY
2021 = KEYUSAGE_TLSKDH_CLIENT_VFY
]]></artwork></figure>

</section>

<section title="Kerberos Ticket and TGT">

<t>Where this text speaks of a TGT, short for Ticket Granting Ticket, it imposes the following requirements to the PrincipalName in the sname field of a Ticket:
<list style="symbols" hangIndent="6">
<t>The name-type is set to NT-SRV-INST or 2;</t>
<t>The name-string consists of two component strings;</t>
<t>The first name-string component string is the fixed string krbtgt.</t>
</list></t>

<t>To be a TGT, all these requirements MUST be met by a Ticket; a Ticket that meets some but not all these conditions is badly formed and the recipient SHOULD respond to it by reporting error bad_certificate and closing the connection.</t>

</section>

<section title="Certificate types">

<t>In order to be able to negotiate Kerberos Tickets as certificate types for
the Certificate messages, a new certifcate type is introduced that can be used
in the "client_certificate_type" and "server_certificate_type" extensions:
<list style="symbols" hangIndent="6">
	<t>Kerberos (TBD:KRBTKT-CERTTP)</t>
</list></t>

<t>This new certificate type is registered at IANA's TLS Certificate Types
registry.</t>

</section>

</section>

<section title="Changes to TLS Messages and Behaviour">

<t>Although TLS-KDH does not introduce any new messages for TLS, there are
however a few modifications to the contents or the manner of processing of existing messages.  Unless specified otherwise, the modifications apply to TLS 1.3 and 1.2 alike.</t>

<section title="ClientHello">

<t>When this message contains the "quantum_relief" extension, its
"qh_method" MUST be set to "kdh" under this specification.  Further
requirements to this extension depend on the pattern of use being
client-to-server [<xref target="kdh-c2s"/>] or peer-to-peer [<xref
target="kdh-p2p"/>].</t>

<t>To initiate client-to-server traffic, the "peernametype" MUST be set to "none", and the "opt_ticket" MUST be a Ticket with the service name, host or domain name and Kerberos realm of the addressed service.  The client name in the "opt_ticket" MAY be an anonymous identity and the server MUST ignore the client identity in the "opt_ticket".  When the "server_name" extension is also sent, there SHOULD be restrictions enforced by the server on its relation with the service name in the "opt_ticket", but this may involve domain-to-hostname mappings, for instance through DNS SRV records under DNSSEC protection.</t>

<t>To initiate peer-to-peer traffic that could be proxied through the TLS
server to end at a responding peer, the "peernametype" MUST NOT be set to "none",
and the "opt_ticket" MUST be a TGT for the TLS client, suited for the ticket
granting service of the TLS server’s realm; it is permitted for the client to
use an anonymous identity in this TGT and the server MUST ignore the client
identity in the "opt_ticket".  When the "peernametype" is set to "krb5princrealm", the "krb5princ" and "krb5realm" fields MUST be set to the Kerberos PrincipalName and Realm for the desired responding peer.  Future extensions may introduce alternative forms of responding peer identity and a TLS server SHOULD be open to the general idea of identity.</t>

<t>When a ClientHello message contains the "quantum_relief" extension, it
MUST NOT include any references to a PSK.  It MAY independently negotiate
client and server certificate types <xref target="RFC7250"/> and
cipher suites.</t>

</section>

<section title="ServerHello">

<t>When the server accepts the "quantum_relief" extension, it replies with
its own "quantum_relief" extension and refrains from making any PSK references.  This specification defines a response to ClientHello extensions with "qh_method" set to "kdh", for which the ServerHello extension MUST be set to "kdh" also.</t>

<t>When the ClientHello extension had its "peernametype" set to "none", the
ServerHello extension responds to a client-to-server connection request.  The
TLS data will be procesed on the server and the response extension MUST set the "opt_ticket" field to a zero-length byte string.</t>

<t>When the ClientHello extension had its "peernametype" set to another value than "none", then the TLS server MUST use this to locate a responding peer, which may have registered through a mechanism not specified herein, and proxy the TLS traffic to this responding peer.  The TLS server continues to proxy this traffic until it closes the connection.</t>

<t>When a responding peer, possibly after registering with a TLS server as a
recipient for client-to-client TLS connections, receives a ClientHello with a
"quantum_relief" extension with "qh_method" set to "kdh" and a
"peernametype" and "peername" that it recognises as its own and with a TGT in
the "opt_ticket" field, it should engage in a user-to-user ticket request with
the ticket granting service for its realm.  It MUST reject the connection if
this procedure fails.  When a Ticket is obtained, it constructs a ServerHello
with a "quantum_relief" extension, sets "qh_method" to "kdh" and
"peernametype" to "none", and "opt_ticket" to the just-obtained Ticket.  Furthermore, it continues to act as though the client had contacted it directly, while being forgiving to the proxied nature of the connection that carries the TLS traffic.  Specifically, there are no grounds for assuming anything about the client identity, which may be undesirable in a client-to-client connection.</t>

</section>

<section title="Server-sent Verify Request">

<t>Since client identity is ignored by the server during ClientHello and
ServerHello and may indeed be toned down to an anonymous identity, any
server-side requiring to know its client MAY send a CertificateRequest in order
to verify the client's identity. The CertificateRequest MUST be send when a
client_certificate_type has been negotiated <xref target="RFC7250"/>. When permitted by the TLS 1.3 client with the post_handshake_auth extension, this MAY also be sent at any later time.  Under TLS 1.2, TLS renegotiation permits a similar facility (with broader impact).</t>

<t>The handshake is not encrypted in TLS 1.2, and for TLS 1.3 in peer-to-peer mode the server-side identity is uncertain until the Finished messages.  In the interest of the privacy of client identity, it may be desirable to add server-side authentication even when it is not otherwise needed.</t>

</section>

<section title="Server-sent Certificate and CertificateVerify">

<t>The Certificate and CertificateVerify messages are not always required,
because (1) the "quantum_relief" extension captures the server identity, and (2) proof thereof is deferred to Finished, which under TLS 1.3 is available to the client before it sends the client Certificate.</t>

<t>Even in cases when it is not strictly required, a server MAY opt for sending
server Certificate and CertificateVerify. However, the absence of the
Certificate and CertificateVerify messages are valid under TLS-KDH and as such clients MUST NOT fail due to the messages being withheld.</t>

<t>The "server_certificate_type" extension may be used to negotiate any
supported type for these messages, including the Kerberos Ticket certificate
type defined herein.  When not negotiated, the default type is X.509.  Note
that a server cannot initiate a Kerberos exchange, so a Kerberos type cannot be
used when the server rejected the "quantum_relief" extension or when the
extension did not provide a Ticket or TGT such as it does when the "qh_method" is "kdh".</t>

</section>

<section title="Client-sent Certificate and CertificateVerify">

<t>Under TLS 1.3, the server can request client authentication by sending a
CertificateRequest message. It is possible for servers to do this at any time (provided that the client has sent the "post_handshake_auth" extension), and possibly multiple times; TLS 1.3 even defines how to handle overlapping requests for client authentication.</t>

<t>Clients MAY choose to respond to a CertificateRequest by sending a
Certificate and CertificateVerify, and the server MAY choose to close the
connection if the client chooses otherwise.</t>

<t>The "client_certificate_type" extension may be used to negotiate any
supported type for
these messages, including the Kerberos Ticket certificate type defined before.
When not negotiated, the default type is X.509.  Note that a client can produce
a Kerberos Ticket even when no "quantum_relief" extension was negotiated
during ClientHello and/or ServerHello, or even when another "qh_method" than
"kdh" was agreed. However, a client MUST NOT send Certifcate and
CertificateVerify messages if it did not receive a CertificateRequest from the
server.</t>

</section>

<section title="Length of Finished">

<t>Under TLS 1.3, the Finished message is as long as the transcript hash.
Under TLS 1.2, this is negotiable.  For TLS-KDH under TLS 1.2 the client MUST
request the "verify_data" length within the Finished message to be as long as
the output length of the
hash being used to compute it, and the server MUST accept this.</t>

</section>

<section title="Selection of Cipher Suites">

<t>Under TLS 1.3, all cipher suites incorporate (Elliptic-Curve)
Diffie-Hellman.  Under TLS 1.2 this is optional.  For TLS-KDH under TLS 1.2 the
client MUST offer cipher suites that include these forms (i.e. ECDHE) of key agreement and the server MUST NOT select a cipher suite without any of these forms of key agreement.</t>

</section>

<section title="Tickets and Connection Expiration">

<t>Tickets in Kerberos represent a key-based connection between two peers.  The
key material in a Ticket is time-limited in the understanding that a client can always request a new Ticket if so desired.  Expiration of a Ticket SHOULD be matched with a teardown of the service.  In terms of TLS-KDH, that means that the connection SHOULD NOT exist beyond the life time of a Ticket.  Each side can independently close down the TLS connection with an ERROR:WHICH alert.</t>

<t>To avoid this, it is possible to request a new client Certificate and
CertificateVerify through a new CertificateRequest, best sent sometime before expiry.  The client then acquires a fresh or prolonged Ticket and once exchanged the connection may continue up to the timeout of the new Ticket.</t>

<t>The timeout is updated by every new Ticket supplied in the "opt_ticket"
field of a "quantum_relief" extension with "qh_method" set to "kdh", or by a Certificate of type Kerberos Ticket, provided that it is followed by a valid CertificateVerify.</t>

<t>A server MUST NOT send data over a connection with a timed-out Ticket, but SHOULD request a fresh one or disconnect.  A client MUST NOT send data over a connection with a timed-out Ticket, but MAY await the arrival a fresh Ticket.  It is a good precaution to request a fresh Ticket a few minutes before the active one expires, to compensate for clock skew between the client and server.</t>

<t>Kerberos supports Tickets with future validity times, intended for such things as nightly batch jobs that require authentication.  By default, a TLS stack MUST reject such Tickets until they start being valid.  It is however possible for applications to override this behaviour and treat the connection especially after being informed of the future time at which it becomes valid.</t>

</section>

</section>

<section title="Cryptographic Updates">

<t>The introduction of the Quantum Relief extension (in combination with
TLS-KDH) leads to a few cryptographic changes to the TLS protocol.  Below, the
three aspects introduced are discussed independently.  Separate treatment for
TLS 1.3 and 1.2 is only necessary for Quantum Relief encryption.</t>

<section title="Quantum Relief for Encryption in TLS 1.3">

<t>Under client-to-server TLS-KDH, the "opt_ticket" in the "quantum_relief"
extension in the ClientHello is used to supply external (quantum proof) key material.  Under peer-to-peer TLS-KDH, the TGT in the "opt_ticket" supplies no shared key material to the client and server (or responding peer), but the ServerHello returns a "quantum_relief" extension with an "opt_ticket" field holding a Ticket that does supply a shared key to use.</t>

<t>This key is used to compute Ticket-Encrypt (opt_ticket, usage,
ClientHello.random || ServerHello.random) where || signifies concatenation, and
usage is either KEYUSAGE_TLSKDH_CLIENT_QR for a Ticket supplied by the client,
or KEYUSAGE_TLSKDH_SERVER_QR for a Ticket supplied by the server side (or
responding peer).  The output of this computation is provided instead of the PSK on
the left of the Key Schedule for TLS 1.3 [page 93 of <xref target="RFC8446"/>].  Had PSK facilities been used, then this seeding would have arrived too late; but since the PSK mechanism is overtaken by TLS-KDH, this problem does not occur.</t>

<t>Other "qh_method" values than "kdh" are likely to come up with other computations.  There may be some that prefer to influence only the master key by replacing the 0 value for key input as it is shown in the TLS 1.3 key schedule.</t>

</section>

<section title="Quantum Relief for Encryption in TLS 1.2">

<t>TLS 1.2 does not offer any form of encryption during the handshake, so Quantum Relief for TLS 1.2 can only be used to strengthen the Master Secret.  When
the "quantum_relief" extension with the "kdh" method is accepted by the server, a Ticket is
available while forming the ServerHello; it is in the ClientHello for
client-to-server mode and in the ServerHello for peer-to-peer mode.  Call this
Ticket qrt and use it to compute Ticket-Encrypt (qrt, KEYUSAGE_TLS12KDH_PREMASTER_QH, ClientHello.random || ServerHello.random),
where || denotes concatenation.  The output of this procedure is a octet string which is prepended to what the cipher-suite defines as its pre-master secret.  This prepended form is then used instead of the normal pre-master secret during the computation of the master key.</t>

</section>

<section title="Kerberos Ticket as Certificate and CertificateVerify">
<!-- TODO deze alinea is naar sectie 4 verplaatst - - dit snapt Rick niet - - gaat het om de IANA Considerations sectie waar dit zou kunnen komen? - - dat geldt dan voor meer dingen en is een terechte opmerking -->
<t>IANA has added Kerberos Ticket with value TBD:KRBTKT-CERTTP to the TLS Certificate Types list in the TLS Extensions Registry.  This can be negotiated independently as client_certificate_type and server_certificate_type, though the latter is impossible without a client certificate, even if it is anonymous or just a TGT; in TLS-KDH, this is available when the server accepts the quantum_relief extension.</t>

<t>The contents of the Certificate message when the certificate type is negotiated as Kerberos is a Kerberos Ticket <xref target="RFC4120"/>.</t>

<t>The contents of the corresponding CertificateVerify message uses this Ticket
k5crt to compute Ticket-Encrypt (k5crt, KEYUSAGE_CLIENT_VFY, th) for a client
CertificateVerify message or Ticket-Encrypt (k5crt, KEYUSAGE_SERVER_VFY, th)
for a server CertificateVerify message, where th is the customary hash up to
and including the preceding Certificate message.  For TLS 1.3, this customary hash uses the transcript hash; for TLS 1.2, the hash algorithm must match the Certificate signing algorithm, which in case of a Kerberos Ticket means its MAC hashing algorithm.</t>

</section>

</section>

<section title="KDH-Only Application Profile">
<t>The default use of TLS involves authentication based on X.509 certificates.
In some scenarios such a PKI is not available or not desirable.  For this
reason, this section defines an alternative, KDH-Only Application Profile.</t>

<t>TLS-KDH-compliant applications MUST implement the TLS_AES_128_GCM_SHA256 [GCM] cipher suite and SHOULD implement the TLS_AES_256_GCM_SHA384 [GCM] and TLS_CHACHA20_POLY1305_SHA256 [RFC8439] cipher suites.</t>

<t>TLS-KDH-compliant applications MUST support the Kerberos Ticket certificate
type.  They also MUST treat X.509 as the default certificate type, but they MAY refuse any attempt to use it, either by negotiating it explicitly or failing to negotiate an alternative.</t>

<t>TLS-KDH-compliant applications MUST support key exchanges with secp256r1
(NIST P-256) and SHOULD support key exchanges with X25519 [RFC7748].</t>

<t>TLS-KDH-compliant applications MUST support the quantum_relief TLS
extension, for which the qh_method value "kdh" MUST be supported, and the peernametype value "none" MUST and "krb5princrealm" SHOULD be supported.</t>

</section>

<section title="Security Considerations">

<t>TODO</t>

</section>

<section title="IANA Considerations">

<t>TODO</t>

</section>

</middle>


<back>

<references title="Normative References">

<!--
<reference anchor='KRB5-KDH'>
<front>
<title abbrev="krb5-kdh">KRB5-KDH: Cryptographically binding Kerberos with Diffie-Hellman</title>
<author initials="R" surname="Van Rein" fullname="Rick van Rein">
<organization>InternetWide.org</organization>
<address>
<postal><street>Haarlebrink 5</street><city>Enschede</city><region>Overijssel</region><code>7544 WP</code><country>The Netherlands</country></postal>
<email>rick@openfortress.nl</email>
</address>
</author>
<date day="11" month="October" year="2014"/>
<abstract>
<t>This specification extends Kerberos with primitives that create a
cryptographic binding between Kerberos authentication and
Diffie-Hellman encryption. This yields their combined advantages.
The variant described as KDH-Only removes server certificates and
end up being secure under our current understanding of Quamtum
Computing.</t>
</abstract>
</front>
</reference>
-->

<!-- DROPPED AS OUT-OF-SCOPE REFERENCE
<reference anchor='KREALM'>
<front>
<title abbrev="krealm">Declaring Kerberos Realm Names in DNS (_kerberos TXT)</title>
<author initials="R" surname="Van Rein" fullname="Rick van Rein">
<organization>InternetWide.org</organization>
<address>
<postal><street>Haarlebrink 5</street><city>Enschede</city><region>Overijssel</region><code>7544 WP</code><country>The Netherlands</country></postal>
<email>rick@openfortress.nl</email>
</address>
</author>
<date day="11" month="September" year="2015"/>
<abstract>
<t>This specification defines methods to determine Kerberos realm
   descriptive information for services that are known by their DNS
   name.  Currently, finding such information is done through static
   mappings or educated guessing.  DNS can make this process more
   dynamic, provided that DNSSEC is used to ensure authenticity of
   resource records.</t>
</abstract>
</front>
</reference>
-->

<!-- EXTERNAL <?rfc include="reference.RFC.1035.xml"?> -->
<!-- <?rfc include="reference.RFC.1510.xml"?> -->
<!-- EXTERNAL <?rfc include="reference.RFC.4033.xml"?> -->
<!-- <?rfc include="reference.RFC.2782.xml"?> -->
<?rfc include="reference.RFC.3961.xml"?>
<?rfc include="reference.RFC.4120.xml"?>
<!-- <?rfc include="reference.RFC.4343.xml"?> -->
<!-- <?rfc include="reference.RFC.4492.xml"?> -->
<!-- <?rfc include="reference.RFC.5226.xml"?> -->
<!-- <?rfc include="reference.RFC.5246.xml"?> -->
<!-- <?rfc include="reference.RFC.5280.xml"?> -->
<!-- <?rfc include="reference.RFC.5746.xml"?> -->
<?rfc include="reference.RFC.5869.xml"?>
<!-- <?rfc include="reference.RFC.6066.xml"?> -->
<!-- <?rfc include="reference.RFC.6806.xml"?> -->
<!-- <?rfc include="reference.RFC.6112.xml"?> -->
<?rfc include="reference.RFC.7250.xml"?>
<!-- <?rfc include="reference.RFC.7627.xml"?> -->
<?rfc include="reference.RFC.8446.xml"?>

</references>

<!--
<references title="Informative References">
-->

<!--
<reference anchor='DNSTXT-KRB1'>
<front>
<title abbrev="DNS TXT &quot;v=krb1&quot;">Finding the Kerberos Realm of a Service in DNS</title>
<author initials="R" surname="Van Rein" fullname="Rick van Rein">
<organization>ARPA2.net</organization>
<address>
<postal>
<street>Haarlebrink 5</street>
<city>Enschede</city>
<region>Overijssel</region>
<code>7544 WP</code>
<country>The Netherlands</country>
</postal>
<email>rick@openfortress.nl</email>
</address>
</author>
<date day="19" month="October" year="2014"/>
<abstract>
<t>This specification defines methods to determine realm names
for services being contacted by their DNS name.  Currently,
finding realm names is done through guessing or local configuration.
DNS can make this process more dynamic, provided that DNSSEC is used
to ensure authenticity of resource records.</t>
</abstract>
</front>
</reference>
-->

<!-- <?rfc include="reference.RFC.2712.xml"?> -->
<!-- <?rfc include="reference.RFC.3280.xml"?> -->
<!-- <?rfc include="reference.RFC.4422.xml"?> -->
<!-- <?rfc include="reference.RFC.4559.xml"?> -->
<!-- <?rfc include="reference.RFC.5801.xml"?> -->
<!-- DTLS: <?rfc include="reference.RFC.6347.xml"?> -->
<!-- <?rfc include="reference.RFC.6698.xml"?> -->
<!-- <?rfc include="reference.RFC.6960.xml"?> -->
<!-- <?rfc include="reference.RFC.7542.xml"?> -->

<!--
</references>
-->

<section title="Acknowledgements" anchor="ack">

<t>This specification could not have matured without the insights of various
commenters.  In order of appearance, we owe thanks to Simo Sorce,
Ilari Liusvaara, Watson Ladd, Benjamin Kaduk, Nikos Mavragiannopoulos,
Kenneth Raeburn.
<!-- now a co-author:
Special thanks go to Tom Vrancken for tracking the development of the
specification, commenting on it and implementing it in GnuTLS.--></t>

<t>This work was conducted under a grant from the programme "[veilig] door
innovatie" from the government of the Netherlands.  It has also
been liberally supported by the NLnet Foundation.</t>

</section>

</back>

</rfc>
